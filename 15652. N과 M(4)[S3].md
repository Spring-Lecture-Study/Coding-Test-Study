# 15652. N과 M(4)[S3]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/15652

# 💻 문제 설명

- 
    
    자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
    
    - 1부터 N까지 자연수 중에서 M개를 고른 수열
    - 같은 수를 여러 번 골라도 된다.
    - 고른 수열은 비내림차순이어야 한다.
        - 길이가 K인 수열 A가 A ≤ A ≤ ... ≤ A ≤ A를 만족하면, 비내림차순이라고 한다.
        
    
    **제한 사항**
    
    한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.
    
    수열은 사전 순으로 증가하는 순서로 출력해야 한다.
    

# **💡 풀이 과정**

## 문제 접근

전 문제들 처럼 백트래킹 알고리즘을 사용하고 dfs(깊이우선탐색) 방법을 활용하여 문제를 풀면 된다. 단, 같은 수를 여러번 골라도 되고, 고른 수열은 **비내림차순**이어야 한다.
비내림차순은 현재 선택한 값은 이전에 선택한 값과 같거나 커야 한다. 즉, **오름차순**으로 정렬을 의미한다. 또한,  **같은 수를 여러번 사용하면서 중복되는 숫자를 출력하면 안된다.**

중복을 방지하려면, **DFS 탐색을 진행할 때, 숫자를 선택한 후 다음 숫자부터 탐색을 시작**하도록 해야 합니다. 즉, 이전에 고른 숫자보다 작은 수는 고를 수 없게 하는 방식으로 처리해야한다.

이를 위해 DFS 메서드에 매개변수로 현재 수열에 넣은 숫자를 전달하고, 다음 깊이를 탐색할 때는 그 숫자부터 다시 시작하여 그 숫자 이후에 값을 수열에 넣도록 한다. 이 방식으로 중복된 수가 출력되지 않도록 하고, 같은 숫자를 여러 번 사용할 수 있다. 수열에 추가한 숫자를 계속해서 넘겨주므로, 현재 값보다 작은 값은 항상 건너뛰게 되어 비내림차순 조건을 만족시킬 수 있다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    public static int N, M;
    public static int[] arr;
    public static StringBuilder sb = new StringBuilder();

    public static void dfs(int depth, int start) {
        if (depth == M) {
            for (int val : arr) {
                sb.append(val).append(" ");
            }
            sb.append("\n");
            return;
        }

        for (int i = start; i <= N; i++) {
            arr[depth] = i;
            dfs(depth + 1, i);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new int[M];

        dfs(0, 1);
        System.out.println(sb);
    }
}
```

## 📋 주요 코드 설명

```java
 public static void dfs(int depth, int start) {
      if (depth == M) {
          for (int val : arr) {
              sb.append(val).append(" ");
          }
          sb.append("\n");
          return;
      }

      for (int i = start; i <= N; i++) {
          arr[depth] = i;
          dfs(depth + 1, i);
      }
  }
```

반복문의 시작을 start 변수값 부터 시작하도록 하여, 만약 깊이가 M에 도달하면, StringBuilder에 수열을 추가하고 return하여 이전 호출로 돌아갑니다. 이때 start 값 이후의 숫자부터 반복문이 시작되므로, 자연스럽게 오름차순으로 출력할 수 있습니다.

예를 들어입력값 N=3, M=3으로 받았다면, DFS 탐색은 먼저 **[1] → [11] → [111] → [112] → [113]** 순으로 진행되어 깊이가 M과 같아지면 수열을 StringBuilder에 추가하고, return을 통해 **dfs(1, 1)**로 돌아간다. 이때, 반복문은 start 값이 갱신되어 1부터 시작했던 값에서 **2부터 다시 시작**하게 되고, **[1 2 2], [1 2 3]**과 같이 수열을 생성한 후,  **[1 3 3]**이 출력됩니다. 그 후, **dfs(1, 2)**로 돌아가서 **[2 2 2]**와 같은 수열이 생성되며, 이후 같은 방식으로 탐색이 진행된다.

# ✏️ **풀이 코드(Python)**

```python
import sys
input = sys.stdin.readline

def dfs(depth, i):
    if depth == M:
        print(" ".join(map(str, arr)))
        return
    for j in range(i, N + 1):
        arr.append(j)
        dfs(depth + 1, j)
        arr.pop()

N, M = map(int ,input().split())
arr = []

dfs(0, 1)
```
