# 1799. 비숍 [P5]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1799

# 💻 문제 설명

- 
    
    정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

비숍은 **좌측 대각선**과 **우측 대각선**으로만 이동할 수 있다. 그리고 비숍을 놓을 수 있는 곳(1)만 놓을 수 있기 때문에, 이를 체크하는 메서드를 작성하여 유효한 위치에만 비숍을 놓는다. 또한,

**백트래킹** 알고리즘을 활용하여 비숍을 최대한 많이 배치할 수 있는 경우를 찾아냅니다.

문제의 핵심은 다음과 같다.

### 좌, 우 대각선 체크

- **좌측 대각선**: 행(row)과 열(col)을 **뺐을 때 값이 같으면** 같은 좌측 대각선에 위치.

<table border="1">
  <tr>
    <td><strong>0,0</strong></td>
    <td>0,1</td>
    <td>0,2</td>
    <td>0,3</td>
  </tr>
  <tr>
    <td>1,0</td>
    <td><strong>1,1</strong></td>
    <td>1,2</td>
    <td>1,3</td>
  </tr>
  <tr>
    <td>2,0</td>
    <td>2,1</td>
    <td><strong>2,2</strong></td>
    <td>2,3</td>
  </tr>
  <tr>
    <td>3,0</td>
    <td>3,1</td>
    <td>3,2</td>
    <td><strong>3,3</strong></td>
  </tr>
</table>

- **우측 대각선**: 행(row)과 열(col)을 **더했을 때 값이 같으면** 같은 우측 대각선에 위치.

<table border="1">
  <tr>
    <td>0,0</td>
    <td>0,1</td>
    <td>0,2</td>
    <td><strong>0,3</strong></td>
  </tr>
  <tr>
    <td>1,0</td>
    <td>1,1</td>
    <td><strong>1,2</strong></td>
    <td>1,3</td>
  </tr>
  <tr>
    <td>2,0</td>
    <td><strong>2,1</strong></td>
    <td>2,2</td>
    <td>2,3</td>
  </tr>
  <tr>
    <td><strong>3,0</strong></td>
    <td>3,1</td>
    <td>3,2</td>
    <td>3,3</td>
  </tr>
</table>

이를 바탕으로 **좌측 대각선**과 **우측 대각선**을 체크하는 배열을 각각 만들고, 해당 대각선에 비숍이 놓여 있는지 여부를 확인하여 비숍을 놓을 수 있는지 판별합니다.

### 백트래킹

체스판에서 특정 좌표에 비숍을 배치할 수 있다면, 좌, 우 대각선 배열을 1(True)로 갱신 후 다음 가능한 좌표 탐색을 진행한다. 만약 탐색이 종료되면, 대각선 배열을 다시 0으로 복구하여 다른 경우의 수 탐색할 수 있도록 한다.

이러한 사항들을 고려하여 풀이하면, 정답을 도출할 수 있지만 전체 판을 탐색해야 하기 때문에 판의 크기가 커지게 되면 계산하는데 오랜 시간이 걸린다.

그렇기 때문에 시간 효율성을 높이기 위해 추가적인 아이디어가 필요하다.

### 두 그룹으로 분리

비숍이 놓인 좌표는 좌측 대각선과 우측 대각선에만 영향을 받습니다. 이 특성을 활용하여 비숍을 놓을 때 행열에 합에 따라 그룹을 나누어 계산합니다.

row \ col

      0  1   2  3   4  5   6  7   

0        | ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪

1        | ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫

2        | ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪

3        | ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫

4        | ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪

5        | ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫

6        | ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪

7        | ⚪     ⚫     ⚪     ⚫     ⚪     ⚫     ⚪     ⚫

- **짝수**: 흑 그룹
- **홀수**: 백 그룹

흑백 그룹 분리의 이유:

좌표 (row, col)의 (row + col) 값에 따라 두 그룹의 대각선은 서로 교차하지 않기 때문에, 두 그룹을 독립적으로 처리할 수 있습니다. 이러한 방식을 화용하여 흑백 그룹을 각각 별도로 탐색합니다. 그렇게 해서 두 그룹의 최대 비숍 개수를 독립적으로 구한 뒤 합산하면 전체 최대 비숍 개수를 얻을 수 있다.

## 코드 접근

### 각 그룹 dfs 호출

비숍을 놓을 때 대각선 영향을 독립적으로 관리하기 위해 좌우측 대각선 배열을 복사([:])하여 각 그룹(흑, 백)을 독립적으로 탐색합니다. dfs 함수는 각 그룹에 대해 대각선 상에서 비숍을 놓을 수 있는지 확인하며, 비숍을 놓을 때마다 max_bishops 값을 갱신합니다. 두 그룹을 각각 탐색하기 때문에 max_bishops는 그룹별로 초기화되며, 탐색 후 그 값을 black_max와 white_max에 저장합니다.

- [:] 문법 설명
    
    슬라이싱을 활용하여 리스트의 모든 요소를 복사하면, 새로운 리스트가 생성됩니다. 이 방식은 원본 리스트와 복사된 리스트가 서로 독립적으로 동작하게 만듭니다.
    

```python
max_bishops = 0
dfs(black_positions, 0, 0, left_diag[:], right_diag[:])
black_max = max_bishops

max_bishops = 0
dfs(white_positions, 0, 0, left_diag[:], right_diag[:])
white_max = max_bishops
```

### dfs

```python
def dfs(positions, depth, left_diag, right_diag):
    global max_bishops

    if depth == len(positions):
        max_bishops = max(max_bishops, count)
        return
```

재귀 호출 함수는 5가지의 매개변수를 받는다.

- **positions**: 탐색할 대각선 그룹의 좌표 리스트
- **depth**: 현재 탐색의 깊이
- **count**: 체스판에 놓은 비숍의 개수
- **left_diag, right_diag**: 좌우측 대각선에 비숍이 있는지 체크하는 배열

**재귀 호출에서 최대값을 갱신하는 이유**

탐색 도중 가지치기를 할 경우, 해당 경로를 끝까지 탐색하지 않기 때문에 놓은 비숍의 개수를 기록하지 않으면 최대값을 놓칠 위험이 있습니다. 따라서, 탐색의 모든 단계에서 현재 상태를 기준으로 최대값을 갱신해야, 가지치기 여부와 상관없이 항상 정확한 결과를 보장할 수 있습니다.

# ✏️ **풀이 코드**

```python
import sys

input = sys.stdin.readline

def dfs(positions, depth, count, left_diag, right_diag):
    global max_bishops
    max_bishops = max(max_bishops, count)

    if depth == len(positions):
        return

    for idx in range(depth, len(positions)):
        row, col = positions[idx]
        if not left_diag[row - col + N - 1] and not right_diag[row + col]:
            left_diag[row - col + N - 1] = True
            right_diag[row + col] = True
            dfs(positions, idx + 1, count + 1, left_diag, right_diag)
            left_diag[row - col + N - 1] = False
            right_diag[row + col] = False

N = int(input())
board = [list(map(int, input().split())) for _ in range(N)]

black_positions = []
white_positions = []

for i in range(N):
    for j in range(N):
        if board[i][j] == 1:
            if (i + j) % 2 == 0:
                black_positions.append((i, j))
            else:
                white_positions.append((i, j))

left_diag = [False] * (2 * N - 1)
right_diag = [False] * (2 * N - 1)

max_bishops = 0
dfs(black_positions, 0, 0, left_diag[:], right_diag[:])
black_max = max_bishops

max_bishops = 0
dfs(white_positions, 0, 0, left_diag[:], right_diag[:])
white_max = max_bishops

print(black_max + white_max)

```
