# 주식 가격 [lv2]

### 🌐 문제 링크:

https://school.programmers.co.kr/learn/courses/30/lessons/42584

# 💻 문제 설명

- 
    
    초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.
    

# **💡 풀이 과정**

## ✍ 문제 접근

문제는 각 초의 주식 가격이 떨어지지 않은 기간을 구하는 것이다.
즉, 각 초를 기준으로 이후 가격을 확인하며, 가격이 떨어지는 순간까지 지속된 시간을 계산한다.

나는 이중 for문을 통해, 현재 초의 주식과 그 이후의 주식의 가격을 비교하였다.
가격이 떨어지면 반복을 종료하고,
가격이 떨어지지 않으면 지속 시간을 증가시켰다.
이렇게 계산한 값을 리스트에 저장하여 최종 결과를 반환하였다.

단순 이중 for 문으로 완전 탐색으로 풀면 쉽다고 생각했는데 시간 복잡도를 구해보면,

최악의 경우 prices 길이가 100,000이면,

이중 for 문이니깐 100,000×100,000=10 ^ 10 승이 된다.
해당 문제에는 시간제한이 없어서 통과됐지만, 효율성이 좋은 코드는 아니다.

# ✏️ **풀이 코드**

```python
def solution(prices):
    result = []
    for idx in range(len(prices)):
        ans = 0
        for i in range(idx, len(prices) -1):
            ans += 1
            if prices[idx] > prices[i + 1]:
                break
        result.append(ans)
    return result
```

# **💡 풀이 과정 - stack 사용**

## ✍ 문제 접근

우리가 필요한 정보는 **각 가격이 몇 초 동안 유지되었는지**, 즉 **언제 처음 가격이 떨어지는지**를 구하는 것이다.

하지만 이중 for문을 사용하면 모든 가격을 일일이 비교해야 하므로 비효율적이다.

이를 개선하기 위해 **스택(Stack)** 을 사용한다.

1️⃣ **스택에는 "가격이 떨어지지 않은 인덱스"를 저장한다.**

2️⃣ **새로운 가격이 들어올 때, 스택에 저장된 마지막 인덱스와 비교하여 가격이 떨어지는 순간을 찾는다.**

- 가격이 떨어지면, 스택에서 비교한 인덱스를 꺼내고,
- 현재 인덱스와 꺼낸 인덱스의 차이를 계산하여 **해당 가격이 유지된 시간을 저장한다.**

3️⃣ **모든 가격을 확인한 후, 스택에 남아있는 인덱스들은 끝까지 유지된 가격들이므로, "배열 끝까지 유지된 초"를 계산하여 처리한다.**

이렇게 하면 **각 원소는 한 번만 스택에 들어가고 한 번만 빠지므로, 시간복잡도는 O(N)으로 최적화된다.**

즉, **이중 for문(O(N²)) 없이도 스택의 pop 연산만 사용하여 효율적으로 해결할 수 있다.**

## 코드 접근

### 가격이 떨어진 구간 찾기

```python
for i in range(len(prices)):  
	  while stack and prices[i] < prices[stack[-1]]:  
	      j = stack.pop()
	      answer[j] = i - j 
	  stack.append(i)  
```

1️⃣ **현재 인덱스(i)의 주식 가격과 스택의 마지막 인덱스(stack[-1])의 주식 가격을 비교한다.**

- 처음에는 스택이 비어 있으므로, 첫 번째 인덱스를 바로 스택에 넣는다.
- 이후부터는 **스택의 마지막 인덱스에 있는 가격과 현재 가격을 비교**한다.

2️⃣ **가격이 떨어졌다면, 스택에서 값을 꺼내 유지된 시간을 계산한다.**

- 스택에 있는 인덱스는 **가격이 떨어지지 않았던 구간의 시작점**을 의미한다.
- 현재 인덱스에서 스택에서 꺼낸 인덱스를 빼면 **가격이 유지된 기간**을 구할 수 있다.

3️⃣ **현재 인덱스를 스택에 저장한다.**

- 이후 가격들과 비교할 수 있도록 **현재 인덱스를 스택에 추가한다.**

이 과정을 반복하면, **모든 가격이 처음으로 떨어지는 시점을 빠르게 찾을 수 있다.**

### 가격이 떨어지지 않은 값들 처리

```python
while stack:  
		j = stack.pop()
		answer[j] = len(prices) - 1 - j
```

스택에 값이 남아 있다는 것은 가격이 끝까지 떨어지지 않았다는 의미이다.

이 경우, 가격이 떨어지지 않은 기간은 마지막 시간까지 유지된 것으로 계산하면 된다.

그래서 결과 배열 인덱스에  (마지막 시간) - (해당 인덱스)를 계산하면 유지 시간을 구할 수 있다.

스택은**먼저 들어온 값이 나중에 나오는 FILO(First In Last Out)** 방식이기 때문에, 처음에 들어온 인덱스 값은 가장 마지막에 나가게 됩니다.

이 때, 스택에서 꺼내는 값은 **마지막에 들어온 값**이므로, **유지 시간이 가장 긴 주식부터 순차적으로 처리**할 수 있게 됩니다.

# ✏️ **풀이 코드**

```python
def solution(prices):
    answer = [0] * len(prices) # 결과 배열
    stack = []  

    for i in range(len(prices)):  
        while stack and prices[i] < prices[stack[-1]]:  
            j = stack.pop()
            answer[j] = i - j 
        stack.append(i)  

    while stack:  
        j = stack.pop()
        answer[j] = len(prices) - 1 - j  

    return answer
```
