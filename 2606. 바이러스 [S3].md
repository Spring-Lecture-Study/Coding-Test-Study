### 🌐 문제 링크:

https://www.acmicpc.net/problem/2606

# 💻 문제 설명

- 
    
    어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

주어진 네트워크 상에 컴퓨터가 연결되어 있는지 구현할려면, **그래프 구조**를 활용해야 한다.

### **그래프**

 연결되어 있는 정점과 정점간의 관계를 표현할 수 있는 자료구조입니다.

이런 그래프라는 개념을 컴퓨터에서 표현하는 방법은 두 가지가 있는데,

1. **인접 행렬**
2. **인접 리스트**

두 방법 중 인접 리스트로 구현하였습니다.

 인접 리스트 방식은 메모리 효율성이 좋고, 연결된 정점만 저장하기 때문에 연결이 적은 그래프(희소 그래프)에 적합하기 때문입니다.

### 인접 리스트 접근

예제 1을 입력으로 받았다고 하면, 다음과 같이 표현할 수 있다.

```python
graph = [
[],        # 0번 컴퓨터 (사용X)
[2, 5],    # 1번 컴퓨터 → 2번, 5번과 연결
[1, 3, 5], # 2번 컴퓨터 → 1번, 3번, 5번과 연결
[2],       # 3번 컴퓨터 → 2번과 연결
[5],       # 4번 컴퓨터 → 5번과 연결
[1, 2, 6], # 5번 컴퓨터 → 1번, 2번, 6번과 연결
[5]        # 6번 컴퓨터 → 5번과 연결
]
```

이처럼 2차원 리스트의 인덱스를 각 컴퓨터의 번호로 생각하고, 해당 인덱스에 연결된 컴퓨터들의 번호를 리스트로 저장하면 그래프 형태를 만들 수 있다.
즉, graph[i]를 조회하면 i번 컴퓨터와 연결된 다른 컴퓨터들의 리스트를 얻을 수 있으며, 이를 활용하여 탐색할 수 있다

이렇게 그래프 자료구조를 활용하여, 네트워크상에 연결되어 있는 컴퓨터를 표현하고, Queue를 t사용하여 1 컴퓨터 부터 연결되어 있는 모든 컴퓨터를 탐색하고 다음 탐색으로 넘어가는 DFS 알고리즘 방식을 활용하여 연결된 컴퓨터들의 수를 도출할 수 있습니다.

❓BFS 메서드를 재귀적으로 호출하지 않았는데 DFS를 사용한 것이 맞나요?

BFS는 **큐**를 사용하여 **너비 우선 탐색**을 수행합니다. 재귀 호출을 사용하지 않고 큐에 넣은 노드를 하나씩 꺼내어 그 인접 노드를 탐색하기 때문에, 재귀적 호출 없이도 탐색을 할 수 있다.

# ✏️ **풀이 코드**

```python
from collections import deque

n = int(input()) 
v = int(input()) 
graph = [[] for i in range(n+1)] 
visited = [0]*(n+1) 

for i in range(v):
    a,b=map(int,input().split())
    graph[a] += [b] # a에 b 연결
    graph[b] += [a] # b에 a 연결 -> 양방향
    
visited[1] = 1 
Q=deque([1])

while Q:
    c = Q.popleft()
    for nx in graph[c]:
        if visited[nx] == 0:
            Q.append(nx)
            visited[nx] = 1
print(sum(visited)-1)
```
