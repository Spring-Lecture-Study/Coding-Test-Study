# 11279. 최대 힙[S2]

# 💻 문제 설명

- 
    
    N개의 개수만큼 정수 x가 주어진다. x가 0이 아닌 자연수라면 배열에 값을 넣는다. 그리고 x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거한다. 이렇게 모든 정수를 입력받았을 때 0이 주어진 횟수 만큼 답을 출력한다.

  Java에서는 힙을 사용하기 위해 **PriorityQueue 클래스를** 사용한다.

PriorityQueue는 기본적으로 **최소힙(min-heap)**을 제공하므로, 최대힙(max-heap)을 구현하려면 커스텀 정렬 규칙을 정의해서 사용해야 한다.

**PriorityQueue 클래스에서 제공하는 주요 메서드**

| 메서드 | 설명 |
| --- | --- |
| offer(E e) | 큐에 요소를 추가합니다. 힙의 정렬 규칙에 따라 삽입 위치를 결정합니다. |
| poll() | 큐의 맨 앞에 있는(우선순위가 가장 높은) 요소를 제거하고 반환합니다. |
| peek() | 큐의 맨 앞에 있는(우선순위가 가장 높은) 요소를 제거하지 않고 반환합니다. |
| isEmpty() | 큐가 비어 있는지 여부를 반환합니다. |
| size() | 큐에 있는 요소의 개수를 반환합니다. |
| clear() | 큐의 모든 요소를 제거합니다. |
| contains(Object o) | 큐에 특정 요소가 포함되어 있는지 여부를 반환합니다. |
| toArray() | 큐의 요소를 배열로 반환합니다. |
| remove(Object o) | 특정 요소를 큐에서 제거합니다. |

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

        for (int i = 0; i < N; i++) {
            int num = Integer.parseInt(br.readLine());
            if (num > 0) {
                maxHeap.offer(num);
            } else {
                if (maxHeap.isEmpty()) {
                    System.out.println(0);
                }else {
                    System.out.println(maxHeap.poll());
                }
            }
        }
    }
}
```

기본 정렬 방식인 최소 힙을 사용할려면,

PriorityQueue<Integer> minHeap = new PriorityQueue<>(); 정의하면 된다.

## 📋 주요 코드 설명

```java
if (num > 0) {
    maxHeap.offer(num);
} else {
    if (maxHeap.isEmpty()) {
        System.out.println(0);
    }else {
        System.out.println(maxHeap.poll());
    }
}
```

- PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);를 사용하여 값을 내림차순으로 정렬하면, 가장 큰 값이 루트에 위치합니다.
- **maxHeap.offer(num)**은 값을 힙에 추가하면서 정렬을 유지하며, **maxHeap.poll()**은 힙에서 가장 큰 값을 제거하고 반환합니다.

- # 1927. 최소 힙[S2]

- ### 🌐 문제 링크:

https://www.acmicpc.net/problem/1927

# 💻 문제 설명

- 
    
    N개의 개수만큼 정수 x가 주어진다. x가 0이 아닌 자연수라면 배열에 값을 넣는다. 그리고 x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거한다. 이렇게 모든 정수를 입력받았을 때 0이 주어진 횟수 만큼 답을 출력한다.
    

# **💡 풀이 과정**

## 문제 접근

이 문제는 입력이 0이라면 배열에서 가장 작은 값을 출력하고 제거해야 한다.

이를 효율적으로 해결하기 위해 **힙 자료구조**를 사용하며, 힙의 기본 동작이 최소힙이기 때문에 추가적인 설정 없이 기본 정의를 그대로 사용하여 문제를 풀면 된다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int i = 0; i < N; i++) {
            int num = Integer.parseInt(br.readLine());
            if (num > 0) {
                minHeap.offer(num);
            } else {
                if (minHeap.isEmpty()) {
                    System.out.println(0);
                } else {
                    System.out.println(minHeap.poll());
                }
            }
        }
    }
}
```

## 📋 주요 코드 설명

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
```

힙의 기본 동작이 최소힙이기 때문에, 최대힙 처럼 추가 설정 필요없이 기본 정의를 정의하여 사용하면 된다.

# 11286. 절대값 힙

### 🌐 문제 링크:

https://www.acmicpc.net/problem/11286

# 💻 문제 설명

- 
    
    N개의 개수만큼 정수 x가 주어진다. x가 0이 아닌 자연수라면 배열에 값을 넣는다. 그리고 x가 0이라면 배열에서 가장 작은 **절대값**을 출력하고 그 값을 배열에서 제거한다. 이렇게 모든 정수를 입력받았을 때 0이 주어진 횟수 만큼 답을 출력한다.
    

# **💡 풀이 과정**

## 문제 접근

이 문제는 입력이 0이라면 배열에서 가장 작은 **절대값**을 출력하고 제거해야 한다.

이를 효율적으로 해결하기 위해 **힙 자료구조**를 사용하며, 힙은 기본적으로 최소힙이기 때문에 값이 작은 것부터 순서대로 나오는 구조 이지만, 문제에서 **절대값 기준으로 가장 작은 값을 정렬**해야 하므로, 사용자 정의 비교 기준(Comparator)를 설정해 정렬 방식을 커스터마이징해서 사용해야 한다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> {
            int absA = Math.abs(a);
            int absB = Math.abs(b);
            if (absA == absB) {
                return a - b;
            }
            return absA - absB;
        });

        for (int i = 0; i < N; i++) {
            int num = Integer.parseInt(br.readLine());

            if (num == 0) {
                if (minHeap.isEmpty()) {
                    System.out.println(0);
                } else {
                    System.out.println(minHeap.poll());
                }
            } else {
                minHeap.offer(num);
            }
        }
    }
}
```

## 📋 주요 코드 설명

```java
if (num == 0) {
  if (minHeap.isEmpty()) {
      System.out.println(0);
  } else {
      System.out.println(minHeap.poll());
  }
} else {
  minHeap.offer(num);
}
```

그 전에 문제들은 입력값이 0보다 클 경우를 제외한 값이 0이기 때문에 else일 경우 가작 작은 값을 출력하도록 하였다. 하지만 이번 문제는 절대값으로 0보다 작은 값들이 이력으로 주어지기 때문에, 먼저 입력이 0이고 비어 있을 경우 0을 출력하게 하고, 힙에 값이 있다면 가장 작은 절대값을 출력하도록 한다.
