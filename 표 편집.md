# 표 편집

### 🌐 문제 링크:

https://school.programmers.co.kr/learn/courses/30/lessons/81303?language=python3

# 💻 문제 설명

- 
    
    n개의 행으로 이루어진 표에서 특정 행을 선택한 상태로 여러 명령을 수행하며, 최종적으로 삭제된 행을 **'X'**, 유지된 행을 **O**로 표시하여 결과를 반환하는 문제이다. 
    
    U X와 D X 명령을 통해 위아래로 이동할 수 있으며, C 명령으로 현재 선택된 행을 삭제하고, Z 명령으로 가장 최근에 삭제된 행을 복구할 수 있다. 삭제된 행은 스택에 저장하여 복구 시 원래 위치에 삽입하며, 삭제 후 다음 행을 선택하되 마지막 행이라면 위쪽 행을 선택해야 한다.
    

# **💡 풀이 과정**

## ✍ 문제 접근

이 문제는 주어진 표에서 특정 행을 이동하거나 삭제 및 복구하는 작업을 수행한 후, 최종 상태를 반환하는 문제이다.

입력값의 크기가 크지만, 가장 먼저 떠오른 방법이 **브루트포스 + 스택**이었기 때문에 이를 활용하여 접근하였다.

명령어에 따라 현재 행의 위치를 이동하고, 삭제하거나 복구하는 과정을 거친다. 

특히, 삭제(C) 시 원래 위치에 복구할 수 있도록 스택에 삭제된 행의 인덱스와 값을 저장하며, 

복구(Z) 시 스택에서 가장 마지막에 저장된 값을 꺼내 원래 위치에 삽입한다.

모든 명령어를 수행한 후, 초기 표와 비교하여 삭제된 행을 ‘X’로 표시한 문자열을 반환하면 된다.

# ✏️ **풀이 코드 - stack 사용**

```python
def solution(n, k, cmd):
    table = [i for i in range(n)]  
    stack = []  

    for c in cmd:
        spl = c.split()
        if spl[0] == "U":  # 위로 이동
            k -= int(spl[1])
            if k < 0:  # 범위를 넘어가면 첫 번째 행에서 멈춤
                k = 0
        
        elif spl[0] == "D":  # 아래로 이동
            k += int(spl[1])
            if k >= len(table):  # 범위를 넘어가면 마지막 행에서 멈춤
                k = len(table) - 1
        
        elif spl[0] == "C":  
            stack.append((k, table[k]))  # (삭제된 인덱스, 삭제된 값) 저장
            del table[k]  # 리스트에서 삭제

            # 다음 행 선택 (마지막 행이었으면 위의 행 선택)
            if k >= len(table):
                k = len(table) - 1
        
        elif spl[0] == "Z":  # 복구 연산
            if stack:
                idx, value = stack.pop()  # 복구할 행 정보 가져옴
                table.insert(idx, value)  # 원래 위치에 삽입
                if idx <= k:  # 복구된 인덱스가 현재 선택된 행보다 앞이면 k 조정
                    k += 1                

    ans = ["O"] * n
    for idx, _ in stack:
        ans[idx] = "X"
    
    return "".join(ans)
```

이 문제에서 주어진 입력값은 n = 999,995, cmd = 200,000 으로 크기가 크다. 

해당 코드처럼 단순 리스트(List)로 삭제 및 복구를 구현하면, 삭제 시 리스트에서 요소를 제거하는 연산(**O(n)**)과 삽입 연산(**O(n)**) 때문에 시간 초과가 발생할 가능성이 크다.

따라서 **연결 리스트**를 활용하여 삭제와 복구 연산을 **O(1)**로 처리하는 것이 핵심이다.

## 코드 접근

### 선택된 행 삭제

```python
elif cmd[0] == 'C':
		prev, nxt = linked_list[k]  # 현재 행의 이전(prev) / 다음(nxt) 행 가져오기
		table[k] = 'X'  # 현재 행을 삭제 표시('X')
		delete.append((prev, k, nxt)) # 삭제한 행을 스택에 저장 (복구할 때 사용)
		
		# 커서 이동
		if nxt == n:
		    k = linked_list[k][0] # 삭제된 행이 마지막이면 이전 행(prev)로 이동  
		else:
		    k = linked_list[k][1] # 아니면 다음 행(nxt)로 이동  
```

현재 선택된 행을 기준으로 연결 리스트에서 이전 행과 이후 행 값을 가져와 각 변수에 저장합니다.

- 이러한 정보를 가져오는 이유는 복구 시 필요할기도 하고, 표에 연결되어 있는 행 하나를 제거했기 때문에 삭제한 행 주위에 행들을 다시 연결하기 위해 필요

이전 테이블과 차이점을 표시하기 위해 “O” → “X”로 표기

복구 명령어가 있을 경우 삭제한 행을 복구하기 위해 정보들을 스택에 저장합니다.

만약, 삭제한 행의 다음행이 마지막 값이라면, 커서를 삭제한 값 이전행으로 이동

그게 아니라면 커서를 다음 행으로 이동.

### 연결 리스트 업데이트

```python
# **2. 연결 리스트 업데이트 (이전/다음 행 연결)**
if prev == -1:  # 첫 번째 행이 삭제된 경우 (이전 행이 없음)
    linked_list[nxt][0] = prev
elif nxt == n: # 마지막 행이 삭제된 경우 (다음 행이 없음)
    linked_list[prev][1] = nxt
else: # 중간 행이 삭제된 경우
    linked_list[prev][1] = nxt
    linked_list[nxt][0] = prev
```

연결 리스트는 각 표의 행들이 **이전 행과 다음 행으로 연결**되어 있다. 그런데 **중간에 표 하나가 삭제**되면, 삭제된 행과 연결되었던 **이전 행과 다음 행을 다시 연결해줘야 한다.**

예시를 들면,

초기 연결 리스트

```python
0 → 1 → 2 → 3 → 4
```

여기서 **2번 행이 삭제**되면,

```python
0 → 1 —— 3 → 4   # 1번행의 이후 값을 3으로, 3번행의 이전 값을 1로 설정해줘야 한다.
```

이렇게 중간에 2번 행이 삭제되면 2와 연결되었던 1번과 3번 행이 연결이 끊겼기 때문에 업데이트 하여 연결해줘야 한다.

그래서 삭제된 행에 따라 다음과 같이 설정해줘야 한다.

- **첫 번째 행이 삭제된 경우**
    - 이전 행이 없으므로, **다음 행의 "이전 값"을 -1(없음)으로 설정.**
- **마지막 행이 삭제된 경우**
    - 다음 행이 없으므로, **이전 행의 "다음 값"을  N(없음)으로 설정.**
- **중간 행이 삭제된 경우**
    - **이전 행과 다음 행을 서로 연결하여 삭제된 행을 건너뛰게 한다.**

### 최근 삭제 된 행 복구

```python
else: 
    prev, now, nxt = delete.pop() # 스택에서 가장 최근에 삭제된 행 정보 가져오기
    table[now] = 'O' # 복구한 행을 'O'로 변경 (삭제 상태 해제)

    if prev == -1: # 복구할 행이 첫 번째 행인 경우
        linked_list[nxt][0] = now
    elif nxt == n: # 복구할 행이 마지막 행인 경우
        linked_list[prev][1] = now
    else: # 복구할 행이 중간에 있는 경우
        linked_list[prev][1] = now
        linked_list[nxt][0] = now
```

해당 코드는 최근 삭제 된 행을 복구하는 과정이다.

최근 삭제된 행을 스택에서 꺼내어 복구하고, 테이블 값을 “O”로 변경한다.

이후, 복구된 행을 기존 연결 리스트에 다시 연결하는데,

- 첫 번째 행이면 다음 행의 이전 값을 갱신
- 마지막 행이면 이전 행의 다음 값을 갱신
- 중간 행이면 이전-다음 행과 다시 연결하여 원래 상태로 복원해준다.

# ✏️ **풀이 코드 - stack 사용**

```python
def solution(n, k, cmds):
    linked_list = {i: [i - 1, i + 1] for i in range(n)}
    table = ['O'] * n
    delete = []

    for cmd in cmds:
        cmd = cmd.split()

        if cmd[0] == 'D':
            for _ in range(int(cmd[1])):
                k = linked_list[k][1]

        elif cmd[0] == 'U':
            for _ in range(int(cmd[1])):
                k = linked_list[k][0]

        elif cmd[0] == 'C':
            prev, nxt = linked_list[k]  
            table[k] = 'X'  
            delete.append((prev, k, nxt)) 
						
            if nxt == n:
                k = linked_list[k][0] 
            else:
                k = linked_list[k][1] 
						
            if prev == -1:  
                linked_list[nxt][0] = prev
            elif nxt == n: 
                linked_list[prev][1] = nxt
            else: 
                linked_list[prev][1] = nxt
                linked_list[nxt][0] = prev
        else: 
            prev, now, nxt = delete.pop() # 스택에서 가장 최근에 삭제된 행 정보 가져오기
            table[now] = 'O' # 복구한 행을 'O'로 변경 (삭제 상태 해제)

            if prev == -1: # 복구할 행이 첫 번째 행인 경우
                linked_list[nxt][0] = now
            elif nxt == n: # 복구할 행이 마지막 행인 경우
                linked_list[prev][1] = now
            else: # 복구할 행이 중간에 있는 경우
                linked_list[prev][1] = now
                linked_list[nxt][0] = now

    return ''.join(table)
```

출처: https://ye0nn.tistory.com/47
