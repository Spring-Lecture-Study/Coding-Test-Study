# 1759. 암호 만들기 [G4]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1759

# 💻 문제 설명

- 
    
    새 보안시스템은 서로 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한, 알파벳은 오름차순 순서대로 출력되어야 한다. L개의 알파벳과 C개의 문자의 종류를 주어졌을때 가능성 있는 모든 암호들을 출력하라.
    

# **💡 풀이 과정**

## 문제 접근

문제를 봤을 때 핵심은 다음과 같다.

### 오름차순 순선대로 출력되어야 한다.

C개의 문자들은 임의의 순서대로 주어지기 때문에 탐색하기 앞서 오름차순으로 정렬해줘야 한다.

### 암호는 최소 한개의 모음과 두개의 자음으로 구성되어야 한다.

알파벳은 모음을 제외하면 나머지는 자음이기 때문에, 깊이 L개가 됐을 때 체크하는 함수를 만들어서 출력하기 앞서 모음이 있는지 확인하고 있을 경우에만 출력한다.

### 중복된 문자를 고르면 안된다.

현재 인덱스 값을 저장하는 변수를 만들고 재귀 호출할때 깊이와 함께 같이 증가시켜, 재귀 호출했을 때 이전 값 이후에 문자를 선택할 수 있게 한다.

이러한 사항들을 고려하여 코드를 작성하였지만, 문법적인 오류로 코드를 구현하지 못했다. 그리고 현재 인덱스를 저장하는 변수와 이전에 인덱스 값을 저장하는 변수는 둘다 중복된 문자를 고르지 않게 하는 역할을 중복적으로 수행하기 때문에 둘 다 사용할 필요가 없다.

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline

def check():
	for ahp in ans:
		if ahp in moem:
			return True
	return False

def dfs(depth, start):
	if depth == L and if check():
		print(*ans)
		return
	
	prev = ""
	for i in range(start, C):
		if apb[i] != prev:
			ans.append(apb[i])
			dfs(depth + 1, i + 1)
			ans.pop()
			prev = apb[i]

L, C = map(int, input().split())
apb = list(input().split())
apb.sort()
ans = []
moem = [a, e, i, o, u]

dfs(0,0)
```

## 코드 접근

### 자음 모음 체크하는 함수

```python
def check():
	for ahp in ans:
		if ahp in moem:
			return True
	return False
	
	# moem = [a, e, i, o, u]
```

영어에서 모음을 제외하면 나머지가 자음이기 때문에 자음 하나만 있는 경우에도 True를 반환하도록 설정했으나, 문제의 정확한 조건(모음 1개 이상, 자음 2개 이상)을 수행하기 위해 자음과 모음을 카운트하는 변수를 check 함수 시작 시 초기화해야한다.

또한, Python에서 알파벳과 같은 문자형 데이터를 저장할 때는 문자열 값을 반드시 **큰따옴표("")** 또는 **작은따옴표('')**로 감싸야 하며, 여러 값을 저장하려면 **리스트([])** 또는 **집합({})**과 같은 자료구조를 사용해야 합니다.

- 정답 코드에서 집합을 사용한 이유는 합이 검색 속도가 더 빠르고 중복 값을 허용하지 않기 때문이다.

### 재귀 호출 함수

```python
def dfs(depth, start):
	if depth == L and if check():
		print(*ans)
		return
	
	prev = ""
	for i in range(start, C):
		if apb[i] != prev:
			ans.append(apb[i])
			dfs(depth + 1, i + 1)
			ans.pop()
			prev = apb[i]
```

위에서 말했듯이 중복된 문자를 고르지 않게 하기 위해 현재 인데스 값을  저장하는 변수와 이전 인덱스 값을 저장한 변수를 사용하는데 이전 인덱스 값을 저장한 변수를 사용하지 않고 조건을 해결할 수 있다.

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline

def check():
    vowels_count = 0
    consonants_count = 0
    for char in ans:
        if char in vowels:
            vowels_count += 1
        else:
            consonants_count += 1
    return vowels_count >= 1 and consonants_count >= 2

def dfs(depth, start):
    if depth == L:
        if check():
            print("".join(ans))
        return

    for i in range(start, C):
        ans.append(apb[i])
        dfs(depth + 1, i + 1)
        ans.pop()

L, C = map(int, input().split())
apb = list(input().split())
apb.sort()
ans = []
vowels = {'a', 'e', 'i', 'o', 'u'}

dfs(0, 0)
```
