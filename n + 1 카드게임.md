# n + 1 카드게임

### 🌐 문제 링크:

https://school.programmers.co.kr/learn/courses/30/lessons/258707

# 💻 문제 설명

- 
    
    1~n 까지의 임의에 순서로 정렬되어 있는 카드 뭉치와 coin개를 이용하여 게임을 할려고 합니다. 카드 뭉치에서 카드를 뽑는 순서가 정해져 있으며, 게임은 다음과 같이 진행합니다.
    
    초기 세팅: 카드 뭉치에서 n/3장을 뽑아 모두 가집니다.(N은 6의 배수이다)
    
    게임은 1라운드로 시작되며, 각 라운드가 시작할 때 카드 두장을 뽑습니다. 만약, 카드 뭉치에 남은 카드가 없다면 게임은 종료됩니다. 그리고 뽑은 카드는 카드 한 장당 동전 하나를 소모해 가지거나, 동전을 소모하지 않고 버릴 수 있습니다.
    
    카드에 적힌 수의 합이 n + 1이 되도록 카드 두 장을 내고 다음 라운드로 진행할 수 있습니다. 만약, 카드 두장을 낼 수 없다면 게임을 종료합니다.
    
    이렇게 게임을 진행했을 때 가능한 최대 라운드의 수를 반환하시오.
    

# **💡 풀이 과정**

## ✍ 문제 접근

주어진 카드에서 짝을 맞출 수 있는 카드를 찾고, 그 과정에서 사용할 수 있는 코인의 수를 고려하여 최대한 많은 라운드를 진행하는 문제입니다. 

이 문제는 카드의 개수가 최대 1,000개로 브루트 포스로 접근할 수 있다고 판단했습니다.

초기에 일정 수만큼 카드를 보유한 후, 남은 카드에서 한 쌍씩 뽑아 짝을 맞추어 진행합니다. 

만약 짝을 맞출 수 없으면 코인을 사용하여 가능한 짝을 찾거나, 두 장 이상의 카드를 통해 짝을 맞추는 방식으로 진행합니다. 

각 라운드마다 카드의 짝을 찾아가는 함수를 사용하여 진행하며, 코인이 부족하거나 짝을 찾을 수 없으면 라운드를 멈추게 되고 최종 진행한 라운드를 반환합니다.

## 코드 접근

### 매칭되는 카드 쌍 제거

```python
def remove_matching_pair(player_cards, available_cards, target_sum):
    for card in player_cards[:]:  
        matching_card = target_sum - card
        if matching_card in available_cards:
            player_cards.remove(card)
            available_cards.remove(matching_card)
            return True
    return False
```

 함수는 두 개의 리스트에서 특정 합을 이루는 카드 쌍을 찾아 제거하는 역할을 합니다.
만약 조건을 만족하는 카드 쌍이 존재한다면, 두 카드 모두 리스트에서 제거한 후 True를 반환합니다.
카드 쌍을 만들 수 없다면 False를 반환하여, 다른 방법(코인을 사용하거나 다음 라운드로 진행 등)을 시도할 수 있도록 합니다.

**매개 변수**

player_cards → 플레이어가 현재 보유한 카드 리스트
available_cards → 상대적으로 사용 가능한 카드 리스트 (현재 보유한 카드, 뽑을 카드)
target_sum → 두 카드의 합이 되어야 하는 목표 값

### 라운드 진행

```python
while coin >= 0 and draw_index < n - 1:  
    drawn_cards.extend(cards[draw_index :draw_index +2]) 

    # 내 카드끼리 짝을 맞출 수 있다면, 그대로 진행
    if remove_matching_pair(player_hand, player_hand, n + 1):
        pass
    # 내 카드와 남은 카드에서 짝을 맞출 수 있으면, 코인 1개를 사용
    elif coin >= 1 and remove_matching_pair(player_hand, drawn_cards, n + 1):
        coin -= 1
    # 남은 카드끼리 짝을 맞출 수 있으면, 코인 2개를 사용
    elif coin >= 2 and remove_matching_pair(drawn_cards, drawn_cards, n + 1):
        coin -= 2
    else:
        break
```

코인이 0 이상이고, 뽑을 카드가 남아 있는 동안 라운드를 진행합니다.

먼저, 현재 가지고 있는 카드끼리 짝을 맞출 수 있는지 확인하고, 가능하면 그대로 진행합니다.
그렇지 않다면, 보유한 카드와 새로 뽑은 카드에서 짝을 맞출 수 있는지 확인하고, 가능하면 코인 1개를 사용합니다.
마지막으로, 뽑은 카드끼리 짝을 맞출 수 있다면 코인 2개를 사용하여 진행합니다.

이때, 각 경우에 따라 차등적으로 코인을 차감하며, 더 이상 진행할 수 없으면 반복문을 종료합니다.

카드를 뽑는 과정에서 append() 대신 extend()를 사용하는 이유는, append()를 사용하면 리스트 전체가 하나의 요소로 추가되기 때문입니다. 반면, extend()를 사용하면 리스트의 요소들이 개별적으로 추가되어 올바르게 카드 리스트에 포함될 수 있습니다.

# ✏️ **풀이 코드**

```python
def remove_matching_pair(player_cards, available_cards, target_sum):
    for card in player_cards[:]:  
        matching_card = target_sum - card
        if matching_card in available_cards:
            player_cards.remove(card)
            available_cards.remove(matching_card)
            return True
    return False
            
def solution(coin, cards):
    answer = 1  # 첫 번째 라운드는 무조건 진행
    n = len(cards)
    player_hand = cards[:n//3]  # 초기 보유 카드 
    draw_index = n // 3  # 남은 카드에서 가져올 첫 번째 인덱스
    drawn_cards= []  # 뽑은 카드 저장 리스트
    
    while coin >= 0 and draw_index < n - 1:  
        # 뽑을 카드 2장 추가
        drawn_cards.extend(cards[draw_index :draw_index +2]) 

        # 내 카드끼리 짝을 맞출 수 있다면, 그대로 진행
        if remove_matching_pair(player_hand, player_hand, n + 1):
            pass
        # 내 카드와 남은 카드에서 짝을 맞출 수 있으면, 코인 1개를 사용
        elif coin >= 1 and remove_matching_pair(player_hand, drawn_cards, n + 1):
            coin -= 1
        # 남은 카드끼리 짝을 맞출 수 있으면, 코인 2개를 사용
        elif coin >= 2 and remove_matching_pair(drawn_cards, drawn_cards, n + 1):
            coin -= 2
        else:
            break
        
        answer += 1
        draw_index += 2 
    
    return answer
```
