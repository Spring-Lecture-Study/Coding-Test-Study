# 15665. N과 M(11)[S2]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/15665

# 💻 문제 설명

- 
    
    N 크기의 수열과 자연수 M이 주어졌을 때, 아래 조건에 만족하는 길이가 M인 수열을 오름차순 순서로 출력해라
    
    **조건**
    
    - 같은 수를 여러 번 골라도 된다.
    - 중복되는 수열을 여러 번 출력하면 안된다.
    - 각 수열은 공백으로 구분해서 출력해야 한다.

# **💡 풀이 과정**

## 문제 접근

문제의 핵심은 같은 수를 여러 번 고르면서도 중복되는 수열을 출력하면 안되는 것이라고 생각했다. 그래서 나는 아래와 같은 방법으로 문제를 해결할려고 했다.

**같은 인덱스의 숫자 여러번 사용**

방문 배열이나 이전에 사용한 값 체크 같은 방법을 사용하지 않으면, 반복문은 재귀 호출할 때에는 같은 인덱스의 숫자를 여러번 사용할 수 있다.

**오름차순 순서로 출력**
현재 주어진 수열은 순서가 임의로 주어지기 때문에 탐색하기 앞서 오름차순으로 정렬해준다.

**중복되는 수열 출력 방지**

집합(set) 자료형을 활용하여 수열이 완성되면 집합에에 넣고, 해당 수열이 집합에 없을 때에만 출력하게 한다. 이렇게 하면 중복된 수열 출력을 방지할 수 있다.

- 값을 집합에 넣을 때 리스트를 튜플로 바꾸는 이유
    
    리스트는 변경 가능한 객체이기 때문에 집합에 넣을 수 없고, 튜플은 변경 불가능한 객체이므로 집합에 저장할 수 있기 때문입니다.
    

하지만  방법은 매번 집합 자료형에서 해당 수열이 있는지 확인해야 하기 때문에, 비효울적이다.(992ms)

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline

def dfs(depth):
    if depth == M:
        result = tuple(ans)
        if result not in results:
            results.add(result)
            print(*result)
        return

    for i in range(N):
        ans.append(arr[i])
        dfs(depth + 1)
        ans.pop()

N, M = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
ans = []
results = set()

dfs(0)
```

## 문제 접근 2

수열에 있는 숫자를 여러 번 고를 수 있으면서 중복된 수열을 출력하지 않는 방법은, **이전 값을 저장하는 변수를 사용**하여 수열에 값을 넣을 때 이전에 사용하지 않았던 값만 넣을 수 있게 한다.

 처음에는 이 방법을 사용하면 수열에 있는 숫자를 여러번 고르지 못한다고 생각했다. 하지만 이전 값을 저장하는 변수는 백트래킹을 통해 이전 호출 함수로 돌아갈 때 초기화 되므로 수열을 넣을 때는 수열내에 중복된 숫자를 고를 수 있고, 이전 호출로 돌아갈 떄는 이전에 사용한 값 이후에 값을 고를 수 있게 된다.  (672ms)

ex/ 

4 2
9 7 9 1

dfs(0), prev = -1, ans =  [1] → dfs(1), prev = -1, ans =  [1 1] →  dfs(2) ans =  [1 1]출력 return, prev = 1 

dfs(1), prev = 1 , ans =[1 7] → dfs(2) ans =[1 7] 출력 return, prev = 7

dfs(1), prev = 7 , ans =[1 9] → dfs(2) ans =[1 9] 출력 return, prev = 9, i = 2

dfs(1), prev = 9, i = 3 반복문 종료

dfs (0),prev = -1, ans [7] → dfs (1),prev = -1, ans [7 7] → dfs (2) ans [7 7] 출력  return, prev =7

……

4번쨰 dfs 때에는 다른 인덱스 여도 이전 값이 같은 숫자이기 때문에 넣을 수 없게 되고 반복문은 종료된다. 그 이후에 dfs(0) i = 0부터 시작했기 때문에 i는 1부터 시작하게 된다. 

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline

def dfs(depth):
    if depth == M:
        print(*ans)
        return

    prev = -1
    for i in range(N):
        if prev != arr[i]:
            ans[depth] = arr[i]
            dfs(depth + 1)
            prev = arr[i]

N, M = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
ans = [-1] * M

dfs(0)
```
