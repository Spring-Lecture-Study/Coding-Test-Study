# 14888. 연산자 끼워넣기[S1]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/14888

# 💻 문제 설명

- 
    
    N개의 정수로 이루어진 수열과, 수열 사이에 끼워 넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로 구성된다.
    
    수와 수 사이에 연산자를 하나씩 배치하여 수식을 만들 수 있으며, 이때 **중복되지 않는 모든 수식**을 고려하여 결과를 계산해야 한다.
    
    결과값 중 **최댓값**과 **최솟값**을 구하는 프로그램을 작성하라.
    

# **💡 풀이 과정**

## 문제 접근

연산자를 담은 배열을 활용해 dfs를 호출하며, 각 단계에서 사용할 수 있는 연산자를 차례로 소모하고 해당 연산 결과를 기반으로 다음 단계를 탐색한다. 특정 조건(모든 연산자를 사용한 경우)에 도달하면 현재 결과값을 최대값과 최소값과 비교해 갱신한 뒤 return한다.

dfs 호출이 종료되면 사용했던 연산자를 복구하여 다른 조합을 탐색하며, 모든 경우의 수를 탐색한 후 최종적으로 최대값과 최소값을 출력한다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    public static int max_value = Integer.MIN_VALUE;
    public static int min_value = Integer.MAX_VALUE;
    public static int N;
    public static int[] arr;
    public static int[] operator = new int[4];

    public static void dfs(int total, int index) {
        if (index == N) {
            max_value = Math.max(max_value, total);
            min_value = Math.min(min_value, total);
            return;
        }

        for (int i = 0; i < 4; i++) {
            if (operator[i] > 0) {
                operator[i] --;

                switch (i) {

                    case 0: dfs(total + arr[index], index + 1); break;
                    case 1: dfs(total - arr[index], index + 1); break;
                    case 2: dfs(total * arr[index], index + 1); break;
                    case 3: dfs(total / arr[index], index + 1); break;

                }
                operator[i] ++;
            }

        }

    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(br.readLine());

        arr = new int[N];

        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i < N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i < 4; i++) {
            operator[i] = Integer.parseInt(st.nextToken());
        }

        dfs(arr[0], 1);

        System.out.println(max_value);
        System.out.println(min_value);

    }
}
```

## 📋 주요 코드 설명

```java
 public static void dfs(int total, int index) {
    if (index == N) {
        max_value = Math.max(max_value, total);
        min_value = Math.min(min_value, total);
        return;
    }

    for (int i = 0; i < 4; i++) {
        if (operator[i] > 0) {
            operator[i] --;

            switch (i) {

                case 0: dfs(total + arr[index], index + 1); break;
                case 1: dfs(total - arr[index], index + 1); break;
                case 2: dfs(total * arr[index], index + 1); break;
                case 3: dfs(total / arr[index], index + 1); break;

            }
            operator[i] ++;
        }
    }
}
```

모든 연산자를 사용했으면 (index == N), 최대값과 최소값을 갱신시킨 후, return을 통해 백트래킹한다. 이때, 반복문을 통해 연산자를 담은 배열에 접근하여 값에 따라 현재 계산된 값에 연산을 적용하고, 연산자가 하나 사용된 후 그 횟수를 복구하여 재귀 호출을 진행한다.

처음에는 operator에는 순차적으로 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로 구성되어 있기 때문에 다양한 순서로 연산을 할 수 없지 않을까 생각했다. 그러나 각 연산자를 하나씩 사용하고 나면 다시 그 연산자를 복구하여 다음 호출에서 다른 연산자를 선택할 수 있게 합니다. 이때, return을 통해 백트래킹이 발생하고, for문에서 그 전에 사용한 값 이후의 연산자부터 다시 선택하게 되어, 모든 연산자의 가능한 조합을 여러 번 시도할 수 있게 된다.

```java
dfs(arr[0], 1);
```

첫 번째 호출에서 arr[0]을 넣은 이유는, 연산을 시작하려면 최소 두 개의 숫자가 필요하므로, 첫 번째 숫자 arr[0]을 넣고, 그 이후부터 연산을 진행하기 위함이다. 그리고 index 값을 1로 설정한 이유는 첫 번째 숫자 이후의 값부터 연산을 시작했다는 의미이다.
