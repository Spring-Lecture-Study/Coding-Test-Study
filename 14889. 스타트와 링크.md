# 14889. 스타트와 링크[S1]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/14889

# 💻 문제 설명

- 
    
    모임에서 축구를 하는데 짝수 N명에서 찬다. 축구를 재미있게 하기 위해서 능력 차이를 최소화 하기 위해 각 멤버별 캐미를 계산하여 나눈 팀의 능력치의 차이의 최솟값을 출력하라.
    참가하는 인원의 번호는 1부터 N까지로 배정되어 있다.
    

# **💡 풀이 과정**

## 문제 접근

문제는 N명의 사람을 두 팀으로 나누어, 각 팀원 간의 캐미 점수(협력 능력치) 합의 차이를 최소화하는 것이 목표이다. 이를 위해 조합을 활용하여 가능한 모든 팀 구성을 탐색하며, boolean 배열을 사용해 팀을 구분합니다. 각 팀 구성이 완료되면 2차원 배열의 캐미 점수를 기반으로 점수를 계산하고, 두 팀의 점수 차이를 절댓값으로 구합니다. 최소값을 갱신하면서 탐색을 반복하며, 점수 차이가 0이 되는 경우 즉시 종료하여 출력한다.

그래서 팀을 구성하는 메서드와 점수를 계산하는 메서드를 나눠어 구성한다.

### 팀원 구성 메서드

현재 인덱스와 선택된 팀원의 수를 입력받아, 팀원의 수가 N의 절반이 되면 팀 점수 차이를 계산하는 메서드를 호출하고 종료합니다. 팀원이 충분히 구성되지 않았다면, 반복문을 통해 현재 인덱스 이후의 값들을 탐색하며 다양한 조합을 만듭니다. 각 탐색 단계에서 팀원으로 선택한 인덱스를 true로 설정하고, 다음 재귀 호출을 통해 팀 구성을 진행합니다. 재귀 호출이 종료되면 해당 인덱스를 다시 false로 되돌려 다른 조합을 탐색할 수 있도록 합니다

### 캐미 점수 계산 메서드

팀원을 확인하는 boolean 배열을 사용해 두 팀을 나누고, 각 팀의 구성원 간 캐미를 이차원 배열에서 조회하여 점수를 합산합니다. 모든 점수를 계산한 후 두 팀 간 점수 차이를 절댓값으로 구합니다. 만약 점수 차이가 0이라면 이는 최소값이므로 바로 결과를 출력하고 프로그램을 종료합니다. 그렇지 않은 경우 현재 점수 차이와 최소값을 비교하여 최소값을 갱신하며, 모든 조합에 대해 계산을 반복합니다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
 
public class Main {
	
	static int N;
	static int[][] map;
	static boolean[] visit;
	
	static int Min = Integer.MAX_VALUE;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 
		N = Integer.parseInt(br.readLine());
 
		map = new int[N][N];
		visit = new boolean[N];
 
 
		for (int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine(), " ");
 
			for (int j = 0; j < N; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
 
		combi(0, 0);
		System.out.println(Min);
 
	}
 
	static void combi(int idx, int count) {

		if(count == N / 2) {

			diff();
			return;
		}
 
		for(int i = idx; i < N; i++) {
			if(!visit[i]) {
				visit[i] = true;	
				combi(i + 1, count + 1);	
				visit[i] = false;	
			}
		}
	}
 
	static void diff() {
		int team_start = 0;
		int team_link = 0;
 
		for (int i = 0; i < N - 1; i++) {
			for (int j = i + 1; j < N; j++) {
				if (visit[i] == true && visit[j] == true) {
					team_start += map[i][j];
					team_start += map[j][i];
				}
				
				else if (visit[i] == false && visit[j] == false) {
					team_link += map[i][j];
					team_link += map[j][i];
				}
			}
		}

		int val = Math.abs(team_start - team_link);
		
		if (val == 0) {
			System.out.println(val);
			System.exit(0);
		}
		
		Min = Math.min(val, Min);
				
	}
}
```

## 📋 주요 코드 설명

```java
static void combi(int idx, int count) {

		if(count == N / 2) {

			diff();
			return;
		}
 
		for(int i = idx; i < N; i++) {
			if(!visit[i]) {
				visit[i] = true;	
				combi(i + 1, count + 1);	
				visit[i] = false;	
			}
		}
	}
```

count가 N의 절반이 되면, 팀이 구성된 것이므로 팀 캐미 점수를 계산하는 메서드를 호출하고 그것이 아니라면, 팀 구성을 위채 반복문을 통해 선택되지 않는 팀원을 구하여 재귀 호출한다.

```java
static void diff() {
		int team_start = 0;
		int team_link = 0;
 
		for (int i = 0; i < N - 1; i++) {
			for (int j = i + 1; j < N; j++) {
				if (visit[i] == true && visit[j] == true) {
					team_start += map[i][j];
					team_start += map[j][i];
				}
				
				else if (visit[i] == false && visit[j] == false) {
					team_link += map[i][j];
					team_link += map[j][i];
				}
			}
		}
```

각 팀의 점수는 0으로 초기화되며, 이중 for문을 통해 계산합니다. 바깥 for문은 0부터 시작하고, 안쪽 for문은 항상 i + 1부터 시작하여, 중복 선택이나 같은 사람을 비교하는 경우를 배제합니다. 각 팀의 구성원은 boolean 배열(visit)을 통해 true인 팀원과 false인 팀원으로 구분됩니다. 반복문 내에서 같은 팀원끼리만 점수를 계산하며, 이차원 배열 map에서 협력 점수를 조회하여 해당 점수를 누적시킵니다.
