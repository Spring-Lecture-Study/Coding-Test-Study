# 15664. N과 M (10) [S2]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/15664

# 💻 문제 설명

- 
    
    문제는 **N 크기의 수열에서 숫자를 중복으로 고르지 않고**, **오름차순**으로 정렬된 중복되지 않은 수열을 공백으로 구분하여 출력해야 한다.
    
    수열 내에서 숫자를 중복으로 고를 수 없는 이유는 예제 2번처럼, 수열의 값이 여러 번 사용 가능하다면 [7, 7] 같은 수열이 출력되어야 하지만, 없는 걸로 봐서 수열에 있는 값을 여러 번 사용할 수 없음을 의미한다. 
    

# **💡 풀이 과정**

## 문제 접근

나의 접근 방법은 다음과 같다.

### 입력 받은 수열 오름차순으로 정렬

일력받은 수열은 순서가 크기와 상관없이 무작위로 주어지기 때문에, 오름차순으로 출력하기 위해 먼저 수열을 오름차순으로 정렬할 필요가 있다고 생각했다.

### 중복된 결과를 방지하기 위한 수열 체크

중복된 결과를 출력하지 않을려면, 완성된 수열을 저장하는 배열을 만들어, 출력하기 전에 배열에 같은 수열이 있는지 확인하고 없을 때 출력하고 저장하게 한다. 이렇게 하면 중복된 결과를 출력을 방지할 수 있다.

### 직전에 선택한 값 이후 탐색

오름차순으로 중복되지 않는 수열을 출력하려면, 현재의 호출에서 고른 인덱스 값을 재귀 호출 매개변수에 넣고, 호출할 때 깊이와 함께 같이 증가시킨다. 이렇게 하면 이전 이나 이 후 호출했을 때 이전에 골랐던 값 이후에 값을 탐색하게 된다. 이렇게 하면 중복된 수열을 출력할 수 없다.

# ✏️ **풀이 코드**

```python
import sys

input = sys.stdin.readline

def dfs(depth, start):
    if depth == M and result not in ans:
        print(" ".join(map(str, result)))
        return

    for i in range(start, N):
        result.append(arr[i])
        dfs(depth + 1, i + 1)
        result.pop()

N, M = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()  
result = []
ans = []
dfs(0, 0)
```

- 하지만 이렇게 풀이할 경우, 입력으로 수열에 같은 숫자가 주어질 경우에 다른 인덱스의 숫자를 뽑아도 같은 결과의 수열을 출력되게 된다.  ex/ 9 7 9 1 → [1 7] [1 9] [1 9] [7 9] [7 9] [9 9]
- 또한, 수열을 저장한 배열을 사용해 중복 확인을 시도했지만, 이는 매번 리스트에 대해 전체 탐색을 해야 하므로 시간 복잡도가 높다.

그래서 중복된 수열을 방지하려면, **동일한 인덱스의 숫자를 반복 선택하지 않도록** 하기 위해 반복문에서 **직전에 선택한 값**과 **현재 값**을 **비교**해야 합니다.
이를 위해, 반복문 내에서 prev 변수를 사용해 이전 값을 기억하고, 같은 값이 등장할 때 건너뛰도록 처리해야 합니다.

## 📋 주요 코드 설명

```python
prev = -1 
    for i in range(start, N):
        if arr[i] != prev:  
            ans.append(arr[i])
            dfs(depth + 1, i + 1)  
            ans.pop()
            prev = arr[i]  
```

이렇게 하면 동일한 인덱스의 숫자를 선택할 수 없으므로 중복 인덱스 숫자와 출력을 방지할 수 있다.

그런데 왜 [9 9]가 출력이 되냐?

같은 호출 안에서 prev는 계속 갱신됩니다. dfs는 재귀 호출마다 독립적으로 prev 값을 갖게 되므로, 새로운 재귀 호출에서는 prev가 독립적으로 갱신됩니다. 그래서 서로 다른 재귀 호출에서 prev 값은 각각 따로 관리되므로 다시 9를 사용할 수 있게 된다.

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline

def dfs(depth, start):
    if depth == M:  
        print(" ".join(map(str, ans)))
        return

    prev = -1 
    for i in range(start, N):
        if arr[i] != prev:  
            ans.append(arr[i])
            dfs(depth + 1, i + 1)  
            ans.pop()
            prev = arr[i]  

N, M = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort() 
ans = []  

dfs(0, 0)
```
