# 1202. 보석 도둑[G2]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1202

# 💻 문제 설명

- 
    
    도둑 상덕이는 보석점을 털기로 결심했다.
    
    상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.
    
    상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## ✏️나의 문제 접근

입력값의 범위가 커서 완전탐색으로는 구현하지 못하고, **dfs**를 활용해서 문제를 풀어야 된다고 생각했다. (잘못된 접근)

**DFS 탐색의 종료 조건**은 가방의 개수가 K개가 되었을 때로 설정한다.
즉, 모든 가방을 탐색한 경우 현재까지 구한 보석의 총 가치와 max_value를 비교하여 **최댓값을 갱신한다.**

그 외의 경우에는, 현재 가방에 담을 수 있는 보석을 하나씩 확인하면서 탐색을 진행한다.
각 보석을 가방에 넣을 수 있다면, 해당 보석을 선택하고 다음 가방을 탐색하도록 재귀 호출한다.
이때, 보석이 이미 선택되었는지 확인하기 위해 **방문 여부를 체크**하고, 백트래킹을 활용하여 탐색이 끝나면 원래 상태로 되돌린다.

또한, 현재 가방에서 어떤 보석도 선택하지 않고 넘어가는 경우도 고려하여,
보석을 선택하지 않은 상태에서 다음 가방을 탐색하는 경우도 함께 재귀 호출한다.

### **🧑‍💻 나의 코드**

```python
import sys
input = sys.stdin.readline

N, K = map(int, input().split()) # 보석의 수와 가방의 개수 입력
jewel = []   # 보석 목록[무게, 가치]
bag_weight = []  # 가방 용량 목록
max_value = 0
visited = [False] * N

for _ in range(N):
    M, V = map(int, input().split())
    jewel.append((M, V))

for _ in range(K):
    bag_weight.append(int(input().strip()))  # 개행 문자 제거를 위해 .strip()사용

jewel.sort()        # 보석의 무게를 기준으로 오름차순 정렬
bag_weight.sort()   # 가방의 용량을 기준으로 오름차순 정렬

def dfs(bag_index, value):
    global max_value
    if bag_index == K:
        max_value = max(max_value, value)
        return

    for index in range(N):
        if bag_weight[bag_index] < jewel[index][0]:
            dfs(bag_index + 1, value)
        elif not visited[index] and jewel[index][0] <= bag_weight[bag_index]:
            visited[index] = True
            dfs(bag_index + 1, value + jewel[index][1])
            visited[index] = False

dfs(0, 0)

print(max_value)
```

DFS 방식은 조건에 따라 탐색을 가지치기(Pruning)하며 최댓값을 갱신할 수 있지만,
이 문제처럼 탐색 범위가 크고 가능한 조합이 많다면, DFS도 결국 지수 시간복잡도를 가지게 되어 비효율적이다.

따라서, 더 효율적으로 풀기 위해서는 가치가 높은 보석을 우선적으로 선택하는 전략이 중요하다.
이를 위해, 보석을 가치(v) 기준으로 내림차순 정렬하고, 가방 용량도 정렬하여 탐색하면 더 빠르게 최적의 해를 찾을 수 있다.

- 이 방법도 위 코드를 더 효율적으로 코딩했을 때,의 사항이지 시간 초과 문제를 해결할 수 있는 방법이 아니다.

## 옳바른 코드 접근(우선순위 큐 활용)

이 문제의 핵심은 **각 가방이 담을 수 있는 보석 중에서 가치가 가장 높은 보석을 선택**하는 것이다.
이를 효율적으로 구현하기 위해 **우선순위 큐(Heap)** 를 활용하여 최적의 보석을 빠르게 선택할 수 있도록 한다.
(Heap은 삽입 및 삭제 연산이 **O(log N**) 의 시간 복잡도를 가지므로, 보석을 빠르게 정렬하고 접근하는 데 유리하다.)

이 문제에서는 **최대 힙(Max Heap)** 을 사용한다.

### **🔹알고리즘 접근 방식 (Greedy + Heap)**

1. **보석과 가방을 정렬하여 탐색을 효율적으로 수행한다.**
    - 보석을 무게 기준으로 오름차순 정렬 → 작은 무게의 보석부터 처리 가능
    - 가방도 무게 기준으로 오름차순 정렬 → 작은 용량의 가방부터 탐색
2. **각 가방에 대해 담을 수 있는 보석들을 힙에 추가한다.**
    - 현재 가방의 무게보다 작은 보석들을 최대 힙(가치 기준)으로 저장
3. 최대 힙에서 가장 가치가 높은 보석을 선택한다.
    - 최대 힙의 루트 노드(가장 큰 가치)를 pop 하여 가방에 넣고, 결과 변수에 누적

이 과정을 반복하면, 각 가방이 담을 수 있는 보석 중에서 가장 가치가 높은 보석을 O(log N) 시간 안에 선택할 수 있어 효율적인 풀이가 가능하다. 

## 코드 접근

### .srtip()

```python
for _ in range(k):
    bags.append(int(input().strip()))
```

가방의 용량을 저장할 때 .strip()을 사용하는 이유는 **개행 문자(\n)**를 제거하기 위해서이다.

sys.stdin.readline()은 입력을 한 줄(\n 포함) 단위로 빠르게 읽어온다. 따라서, int(input())을 하면 개행 문자가 포함되어 **ValueError**가 발생할 수 있다.
이를 방지하기 위해 .strip()을 사용하여 개행 문자를 제거한다.

단, input().split()을 사용하면 개행 문자가 자동으로 제거되므로 .strip()이 필요 없다.

```python
for bag in bags:
    while jewel_idx < n and jewels[jewel_idx][0] <= bag:
        heapq.heappush(max_heap, -jewels[jewel_idx][1])  
        jewel_idx += 1

    if max_heap:
        total_value += -heapq.heappop(max_heap)  
print(total_value)
```

❓ heapify를 사용하지 않고 어떻게 힙을 사용하는가?

**리스트에 값이 미리 들어 있는 경우,** 이를 힙으로 변환하려면 **heapify()**를 사용해야 한다.
그러나 이번 문제에서는 빈 리스트에서 시작하여 하나씩 heappush()로 값을 삽입하기 때문에
Python의 heapq 모듈이 자동으로 힙 구조를 유지해 준다.

- 따라서 heapify()를 사용할 필요가 없다.

해당 코드는 가장 작은 용량의 가방부터 담을 수 있는 보석을 최대힙에 넣고, 루트노드에 있는 값에 접근하여 결과 변수에 누적시키는 코드이다.

최대힙으로 접근하기 위해 heappush, heappop을 할 때 첫 번째 인자인 리스트에 **“-”**부호를 붙인다.

```python
for bag in bags:
    while jewels and jewels[0][0] <= bag:
        heapq.heappush(max_heap, -jewels[0][1])
        heapq.heappop(jewels)
    if max_heap:
        total_value += -heapq.heappop(max_heap)
print(total_value)
```

위의 코드처럼 보석의 인덱스를 사용하지 않고, 현재 가방에서 넣을 수 있는 보석을 힙에 넣고, 보석을 저장하는 리스트에서 해당 보석을 제거한다. 이렇게 하면, while 조건에 인덱스를 사용하지 않고 보석이 남아있을 때 까지 루프를 돌게 된다.  

**❓ jewels는 힙도 아닌데 어떻게 heappop를 사용하는가?** 

heappop은 정렬된 리스트에서 사용이 가능하기 때문에, jewels는 위에서 오름차순으로 정렬해서 사용이 가능하다.

# ✏️ **풀이 코드**

```python
import sys
import heapq

input = sys.stdin.readline

n, k = map(int, input().split())  
jewels = []  
bags = []  

for _ in range(n):
    m, v = map(int, input().split())  # 무게, 가치
    jewels.append((m, v))

for _ in range(k):
    bags.append(int(input().strip()))

jewels.sort()
bags.sort()

max_heap = []
total_value = 0
jewel_idx = 0

for bag in bags:
    while jewel_idx < n and jewels[jewel_idx][0] <= bag:
        heapq.heappush(max_heap, -jewels[jewel_idx][1]) 
        jewel_idx += 1

    if max_heap:
        total_value += -heapq.heappop(max_heap)  
print(total_value)

```
