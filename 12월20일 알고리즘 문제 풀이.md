# 2630. 색종이 만들기

### 🌐 문제 링크:

https://www.acmicpc.net/problem/2630

# 💻 문제 설명

- 
    
    주어진 정사각형 종이는 **하얀색(0)** 또는 **파란색(1)**으로 이루어져 있다.
    
    종이가 모두 같은 색이 아니면 가로와 세로로 **4등분**하여 나누고, 나눈 영역에서도 같은 색이 아닐 경우 같은 방식으로 반복해서 자른다.
    
    이 과정은 각 영역이 모두 같은 색이거나, 하나의 정사각형 칸이 될 때까지 계속된다.
    
    최종적으로 만들어진 하얀색과 파란색 색종이의 개수를 구하는 문제이다.
    

# **💡 풀이 과정**

## 문제 접근

 처음에는 주어진 종이 전체가 동일한 색인지 확인하고, 크기가 1이 될때 까지 종이 전체가 동일한 색인지 확인 해야한다.

색이 모두 같다면, 해당 색의 결과값을 증가시키고 나누는 작업을 중단한다.

색이 다르다면, 가로와 세로로 4등분 해서 색상이 같은지 확인하다.

가로와 세로를 4등분한다는 것은, 주어진 정사각형 영역을 4개의 작은 정사각형으로 나누는 작업이다. 우선 입력값 N 크기의 전체 영역이 동일한 색인지 확인하고, 색이 다르면 N 크기의 반인 N/2로 나누어 4개의 영역으로 분할하여 각 영역의 색을 확인하는 과정을 반복한다.

4개의 영역의 범위는 다음과 같다.

**왼쪽 위 (I)**:
시작 좌표: (x, y)
크기: half x half
범위: (x,  x + half),( y, y + half)
2. **오른쪽 위 (II)**:
시작 좌표: (x, y + half)
크기: half x half
범위: (x, x + half), (y + half, y + size)
3. **왼쪽 아래 (III)**:
시작 좌표: (x + half, y)
크기: half x half
범위:( x + half, x + size),( y,  y + half)

4. **오른쪽 아래 (IV)**:
시작 좌표: (x + half, y + half)
크기: half x half
범위:( x + half,  x + size),( y + half,  y + size)

가정: size = 8 (8x8 크기의 종이), 시작 좌표 (x=0, y=0)

half = 8 // 2 = 4
각 영역을 나누면:
왼쪽 위 (0, 0)부터 (3, 3)까지: 크기 4x4
오른쪽 위 (0, 4)부터 (3, 7)까지: 크기 4x4
왼쪽 아래 (4, 0)부터 (7, 3)까지: 크기 4x4
오른쪽 아래 (4, 4)부터 (7, 7)까지: 크기 4x4

| (0,0) | (0,1) | (0,2) | (0,3) | (0,4) | (0,5) | (0,6) | (0,7) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| (1,0) | (1,1) | (1,2) | (1,3) | (1,4) | (1,5) | (1,6) | (1,7) |
| (2,0) | (2,1) | (2,2) | (2,3 | (2,4) | (2,5) | (2,6) | (2,7) |
| (3,0) | (3,1) | (3,2) | (3,3) | (3.4) | (3,5) | (3,6) | (3,7) |
| (4,0) | (4,1) | (4,2) | (4,3) | (4,4) | (4,5) | (4,6) | (4,7) |
| (5,0) | (5,1) | (5,2) | (5,3) | (5,4) | (5,5) | (5,6) | (5,7) |
| (6,0) | (6,1) | (6,2) | (6,3) | (6,4) | (6,5) | (6,6) | (6,7) |
| (7,0) | (7,1) | (7,2) | (7,3) | (7,4) | (7,5) | (7,6) | (7,7) |

N크기 부터 모두 같은 색인지 확인하고, 아니라면 N의 크기를 반으로 나눠어 4개의 영역에 걸쳐 확인하고 이렇게 N크기 1이 될떄까지 분할하고 결과값을 출력하면 된다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static int[][] paper;
    public static int[] result = new int[2];

    public static boolean isSingleColor(int x, int y, int size) {
        int color = paper[x][y];
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                if (paper[i][j] != color) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void countColors(int x, int y, int size) {
        if (isSingleColor(x, y, size)) {
            result[paper[x][y]]++;
        } else {
            int half = size / 2;
            countColors(x, y, half); // 왼쪽 위
            countColors(x, y + half, half); // 오른쪽 위
            countColors(x + half, y, half); // 왼쪽 아래
            countColors(x + half, y + half, half); // 오른쪽 아래
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine()); 
        paper = new int[N][N];

        for (int i = 0; i < N; i++) {
            String[] row = br.readLine().split(" ");  
            for (int j = 0; j < N; j++) {
                paper[i][j] = Integer.parseInt(row[j]);  
            }
        }
        countColors(0, 0, N);

        System.out.println(result[0]); // 하얀색(0) 개수
        System.out.println(result[1]); // 파란색(1) 개수
    }
}
```

## 📋 주요 코드 설명

```java
} else {
		// 영역을 4개로 나누어 재귀 호출
		int half = size / 2;
		countColors(x, y, half); // 왼쪽 위
		countColors(x, y + half, half); // 오른쪽 위
		countColors(x + half, y, half); // 왼쪽 아래
		countColors(x + half, y + half, half); // 오른쪽 아래
		}
}
```

현재 영역의 색이 같은 색상이 아니라면, 현재 영역의 크기를 반으로 나눠고, 4개의 영역별로 색상이 맞는지 재귀적으로 호출하여 확인한다.

# 📒 **풀이 후기**

1️⃣ **분할 정복**

- **핵심 아이디어**: 문제를 작게 쪼개어 해결한 뒤, 결과를 합쳐서 전체 문제를 해결.
- **구조적 특징**:
    - 문제를 **재귀적으로 쪼갬**.
    - 특정 조건(기저 조건)에서 더 이상 쪼개지 않음.
    - 각 부분 문제를 **병렬적으로 해결할 필요가 없으며**, 해결된 결과를 조합해 최종 결과를 생성.

 # 1992. 쿼드트리

 ### 🌐 문제 링크:

https://www.acmicpc.net/problem/1992

# 💻 문제 설명

- 
    
    흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.
    
    주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다.
    
    위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 **"(0(0011)(0(0111)01)1)"**로 표현된다. N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

문제는 이전에 풀었던 색종이 만들기와 거의 유사하다. 

입력값 𝑁 크기의 2차원 배열에서 각 영역의 값이 같은지 확인하고, 다르다면 4개의 영역으로 나누어 값을 재귀적으로 확인한다.

단, 이번 문제에서는 결과를 4개의 영역으로 압축한 결과를 **괄호 안에 묶어서 표현**해야 한다.
즉, 각 영역의 결과를 문자열 형태로 출력해야 한다.

- 처음 N크기부터 비교하여 4개의 영역을 확인한다면,  “(”를 결과값에 넣어줘야 하고, 4개의 영역 비교가 끝나다면 “)” 넣어줘야 한다.

이떄, 결과값은 문자열 형태로 출력해야 하므로, **StringBuilder**를 사용해 조건에 따라 결과를 효율적으로 조합한다.

- Java에서는 String객체는 불변 객체이기 때문에, 한 번 생성된 문자열은 변경할 수 없다.
- StringBuilder는 mutable(가변) 클래스입니다. 즉, 문자열을 수정하거나 추가할 때 새로운 객체를 생성하지 않고 내부 배열을 수정합니다.
따라서, 문자열을 자주 수정하거나 추가하는 작업에서는 훨씬 효율적이다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

    public static int[][] video;
    public static StringBuilder sb = new StringBuilder();

    public static boolean isSingleColor(int x, int y, int size) {
        int color = video[x][y];
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                if (video[i][j] != color) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void compress(int x, int y, int size) {
        if (isSingleColor(x, y, size)) {
            sb.append(video[x][y]);
        } else {
            sb.append("("); 
            int half = size / 2;
            compress(x, y, half); // 왼쪽 위
            compress(x, y + half, half); // 오른쪽 위
            compress(x + half, y, half); // 왼쪽 아래
            compress(x + half, y + half, half); // 오른쪽 아래
            sb.append(")"); // 끝 괄호 추가
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        video = new int[N][N];

        for (int i = 0; i < N; i++) {
            String line = br.readLine();
            for (int j = 0; j < N; j++) {
                video[i][j] = line.charAt(j) - '0'; 
            }
        }
        compress(0, 0, N);

        System.out.println(sb.toString());
    }
}
```

## 📋 주요 코드 설명

```java
 else {
    sb.append("("); // 시작 괄호 추가
    int half = size / 2;
    compress(x, y, half, video); // 왼쪽 위
    compress(x, y + half, half, video); // 오른쪽 위
    compress(x + half, y, half, video); // 왼쪽 아래
    compress(x + half, y + half, half, video); // 오른쪽 아래
    sb.append(")"); // 끝 괄호 추가
}
```

현재 영역의 숫자가 모두 같지 않으면, 영역을 4등분하여 각 부분을 재귀적으로 탐색합니다.

- 재귀 호출 전에 시작 괄호 “(”를 결과에 추가합니다.
- 네 영역에 대한 탐색이 모두 완료되면 끝 괄호 “)”를 추가하여 해당 영역의 압축 결과를 괄호로 묶습니다.

# 1780. 종이의 개수

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1780

# 💻 문제 설명

- 
    
    N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.
    
    1. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
    2. (1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.
    
    이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

이번 문제는 하나의 공간을 9개로 분할하여 풀어내는 문제다.
전에 풀었떤 문제처럼 N*N 크기에 이차원 배열을 순회하면서 숫자가 같은지 확인한다. 여기서 이전 문제와 달리 9개의 영역으로 나누어야 한다.

9개의 영역으로 분할 할 때에는, 각 시작 좌표와 끝 좌표까지 접근할 수 있도록 설계한다.

 

```java
partition(x, y, newSize);								// 왼쪽 위
partition(x, y + newSize, newSize);						// 중앙 위
partition(x, y + 2 * newSize, newSize);					// 오른쪽 위

partition(x + newSize, y, newSize);						// 왼쪽 중간
partition(x + newSize, y + newSize, newSize);			// 중앙 중간
partition(x + newSize, y + 2 * newSize, newSize);		// 오른쪽 중간

partition(x + 2 * newSize, y, newSize);					// 왼쪽 아래
partition(x + 2 * newSize, y + newSize, newSize);		// 중앙 아래
partition(x + 2 * newSize, y + 2 * newSize, newSize);	// 오른쪽 아래
```

위에서 아래, 왼쪽에서 오른쪽 순서로 값을 순회하도록 한다.

위 영역은 x는 그대로 y는 점점 newSize에 더하거나 2를 곱한 값을 더하게 하여 우측으로 접근하도록 한다.

중간 영역은 x에 현재영영 크기값을 더하고, y는 위와 같이 진행한다.

마지막 아래 영역은 x는 newSize에 2를 곱한 값과 더하면 되고 y는 위와 동일 하다.

이처럼 전체 영역이 같은 숫자가 아닐경우 같은 크기의 종이를 9개로 분할하여, 영역에 숫자를 확인하는 메서드를 재귀적으로 호출해야 한다.

위와 같이 9개의 영역을 접근할 수 있지만, 단순 for문을 통해 9개의 영역을 분할 할 수 있다.

```java
for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
		    partition(x + i * newSize, y + j * newSize, newSize, board);
		}
}
```

i랑 j값이 증가할 때 마다 9개의 영역에 시작좌표부터 끝 좌표까지 접근하기 때문에, 위에 방법보다 더 효율적인 방법이다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    public static int[][] board;

    public static boolean isSingleColor(int x, int y, int size, int[][] board) {
        int color = board[x][y];
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                if (board[i][j] != color) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void partition(int x, int y, int size) {
        if (isSingleColor(x, y, size, board)) {
            int color = board[x][y];
            if (color == -1) {
                result[0]++; // -1 (GRAY)
            } else if (color == 0) {
                result[1]++; // 0 (WHITE)
            } else {
                result[2]++; // 1 (BLACK)
            }
        } else {
            int newSize = size / 3;

            partition(x, y, newSize);								// 왼쪽 위
            partition(x, y + newSize, newSize);						// 중앙 위
            partition(x, y + 2 * newSize, newSize);					// 오른쪽 위

            partition(x + newSize, y, newSize);						// 왼쪽 중간
            partition(x + newSize, y + newSize, newSize);			// 중앙 중간
            partition(x + newSize, y + 2 * newSize, newSize);		// 오른쪽 중간

            partition(x + 2 * newSize, y, newSize);					// 왼쪽 아래
            partition(x + 2 * newSize, y + newSize, newSize);		// 중앙 아래
            partition(x + 2 * newSize, y + 2 * newSize, newSize);	// 오른쪽 아래
        }
    }

    public static int[] result = new int[3]; 

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        board = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < n; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        partition(0, 0, n);

        System.out.println(result[0]); // -1 (GRAY) 개수
        System.out.println(result[1]); // 0 (WHITE) 개수
        System.out.println(result[2]); // 1 (BLACK) 개수
    }
}
```
