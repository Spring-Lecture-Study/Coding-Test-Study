# 아이템 줍기

### 🌐 문제 링크:

https://school.programmers.co.kr/learn/courses/30/lessons/87694#qna

# 💻 문제 설명

- 
    
    여러개의 사각형 정보(좌측 하단 좌표와 우측 상단 좌표)가 주어졌을 때, 테두리를 따라 아래와 같이 다각형 모양 지형이 만들어진다. 그 위에 캐릭터의 위치와 아이템의 위치가 주어졌을 때 아이템까지의 최단 거리를 구하라.
    
    ![Image](https://github.com/user-attachments/assets/6bc97d3d-f3b8-4f4f-993e-d68921afae77)
    

# **💡 풀이 과정**

## 문제 접근

문제는 **BFS** 알고리즘 방법과 **Queue** 자료 구조를 활용하여 풀어야 한다.

❓**왜 BFS 와 Queue를 사용해야 하는가?**

캐릭터 위치와 아이템의 위치가 주어졌을 때, 아이템 까지의 **최단거리**를 구해야 한다. 

이때 DFS를 사용할 경우 **한 경로를 깊게 탐색하는 방식**이라서 비효율일 수 있고, 여러 경로를 탐색하는 데 시간이 많이 걸릴 수 있습니다.

그런데 BFS 같은 경우 **동시에 여러 방향을 탐색**하기 때문에 가장 빠르게 도달한 경로를 찾을 수 있어 최단 경로 문제에 적합합니다. 그리고 Queue는 **FIFO** 구조로, 먼저 들어온 것이 먼저 나가게 됩니다. 그래서 이를 활용하여 현재 캐릭터 위치에서 조건에 해당하는 곳만 이동하게 하고, 해당 좌표와 누적한 이동거리를 queue에 넣게한다. 

이때, 캐릭터가 아이템에 도착하게 된다면 여러 방법 중 **가장 먼저 도착한 경우가 출력**되기 때문에 **BFS + Queue** 방법을 사용해야 한다.

이를 적용하여 문제를 풀기 위해서는 두가지 과정이 필요합니다.

1. **테두리를 따라 게임 맵을 만들어야한다.**
2. **그 테두리를 따라 최단거리를 구하면 된다.**

1번 같은 경우 문제 그대로 구현할 경우 오류가 발생한다.

문제에서 가로, 세로 크기가 최대 50으로 주어졌기 때문에, 이를 기반으로 **-1로 채워진 2차원 리스트**를 만들고, 주어진 **사각형 정보**를 처리하여 **내부는 2로**, **테두리는 1로** 설정합니다.

 그런데 아래처럼 주어졌을 때, 형광색(테두리)을 따라서 탐색해야 하지만 빨간색 부분과 같은 경우 5→ 6→ 7→ 6 이런 순서가 아닌, 인접한 부분으로 바로 넘어가서 5→ 6으로 이동하는 문제가 발생할 수 있습니다.

![Image](https://github.com/user-attachments/assets/569c81ba-c26f-4a3a-b4d6-09355469c464)

출처: https://eunbin00.tistory.com/187?category=948906

이를 해결하기 위해 **게임 맵 크기를 두 배로 늘리는 방식**을 사용합니다. 이렇게 하면 **테두리만 정확하게 구별할 수** 있고, **각각의 격자 사이에 구분이 생겨** 올바르게 테두리만 따라가며 최단 거리를 구할 수 있습니다. 

단, 맵 크기가 두 배로 늘었기 때문에, **도달했을 때 최단 거리를 2로 나누어 원래 크기로 환산**해야 합니다.

![Image](https://github.com/user-attachments/assets/08f6c6cc-f20c-4df2-81b1-84b4a2a06211)

## 코드 접근

### 맵 구현

```python
def solution(rectangle, characterX, characterY, itemX, itemY):
    SIZE = 102
    grid = [[0] * SIZE for _ in range(SIZE)]
    
    for x1, y1, x2, y2 in rectangle:
        x1, y1, x2, y2 = x1 * 2, y1 * 2, x2 * 2, y2 * 2 
        # x1, y1, x2, y2 = map(lambda x: x * 2, rectangle) 도 가능
        for x in range(x1, x2 + 1):
            for y in range(y1, y2 + 1):
                # 내부를 2 (벽), 테두리를 1 (이동 가능)으로 설정
                if x1 < x < x2 and y1 < y < y2:
                    grid[x][y] = 2  # 내부
                elif grid[x][y] != 2:
                    grid[x][y] = 1  # 테두리

```

이 코드는 주어진 사각형 정보(rectangle)를 바탕으로 **2배 확장된 맵**을 만들어서 **테두리**와 **내부**를 구분하는 과정을 구현한 것입니다.

for문을 통해 내부와 테두리에 대하여 맵을 구현합니다.

❓ 맵 구현 중 사각형이 겹치는 구간을 어떻게 처리해야 할까?
사각형이 겹치는 영역이 있어도, 그 **겹친 부분도 테두리로 처리**되므로 BFS가 탐색하는 것은 **테두리**입니다. 결국 **테두리만 따라 이동**하는 과정에서 **내부는 무시**되기 때문에 겹침이 최단거리 계산에 영향을 미치지 않습니다.

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 **2 2 2 2** 0 0 0 0 0 0 0 0 0 0 0
0 **2 2 2** 1  1  **2** **2 2 2 2** 0 0 0 0 0 0 0
0 **2** 1 **2** 1   1 **2** **2**  1   1 **2** 0 0 0 0 0 0 0
0 **2** 1 **2 2  2 2 2 2  2 2** 0 0 0 0 0 0 0
0 **2** **2** **2** 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

# ✏️ **풀이 코드**

```python
from collections import deque

def solution(rectangle, characterX, characterY, itemX, itemY):
    SIZE = 102
    grid = [[0] * SIZE for _ in range(SIZE)]
    
    for x1, y1, x2, y2 in rectangle:
        x1, y1, x2, y2 = x1 * 2, y1 * 2, x2 * 2, y2 * 2
        for x in range(x1, x2 + 1):
            for y in range(y1, y2 + 1):
                # 내부를 2 (벽), 테두리를 1 (이동 가능)으로 설정
                if x1 < x < x2 and y1 < y < y2:
                    grid[x][y] = 2  # 내부
                elif grid[x][y] != 2:
                    grid[x][y] = 1  # 테두리

    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    
    q = deque([(characterX * 2, characterY * 2, 0)])
    visited = [[False] * SIZE for _ in range(SIZE)]
    visited[characterX * 2][characterY * 2] = True
    
    while q:
        x, y, dist = q.popleft()
        
        if (x, y) == (itemX * 2, itemY * 2):
            return dist // 2  
    
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < SIZE and 0 <= ny < SIZE and not visited[nx][ny] and grid[nx][ny] == 1:
                visited[nx][ny] = True
                q.append((nx, ny, dist + 1))

```
