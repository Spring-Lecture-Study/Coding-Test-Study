# 3109. 빵집[G2]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/3109

# 💻 문제 설명

- 
    
    원웅이는 근처 빵집의 가스관과 원웅이의 빵집을 연결하는 파이프를 설치하려고 한다. 
    가스관과 빵집을 연결하는 모든 파이프라인은 **첫 번째 열**에서 시작해야 하고, **마지막 열**에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있다. 또한, 빵집과 가스관 사이에는 건물이 있을 수 있는데, 이곳에는 파이프를 놓을 수 없다.
    
    원웅이는 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.
    
    원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

문제의 핵심은  원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 **파이프라인의 최대 개수**를 구하는 것이다.

이렇게 최대 개수를 구하는 문제는 전체 개수를 구하고 그 중에 최대 개수를 구해야 하기 때문에 **dfs**에 적합하다. 또한, R과 C의 입력값의 범위는 (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500) 이고 시간복잡도를 대략 계산해보면 10^5 * 5 = 5,000,000 이기 때문에 1초(10⁷)가 넘지 않으므로 dfs로 풀 수 있다.

dfs로 풀기 앞서, 파이프라인을 연결할 수 있는 방향은 **오른쪽 대각선 위(↗**), **오른쪽(**➡️**)**, **오른쪽 대각선 위(↘**)이다.
이때, 탐색을 최적화하기 위해 **"오른쪽 대각선 위부터 탐색**"하는 것이 중요하다.

**❓왜 오른쪽 대각선 위부터 탐색해야 할까?**

한 번 연결된 경로는 다시 변경되지 않기 때문에, 최적의 탐색 순서가 중요하다. 그런데 아래쪽부터 탐색하면 위쪽에서 탐색할 기회가 사라질 수 있다. 그렇기 때문에 위쪽 경로를 우선적으로 확보하면 **더 많은 파이프라인을 설치할 가능성이 높아진다.**

이러한 접근 방법을 적용하여 코드에 접근하면 다음과 같다.

1. 반복문을 통해 0행부터 R-1행까지 순회하면서 DFS를 호출합니다.
2. 호출된 DFS 함수는 오른쪽 대각선 위(↗), 오른쪽(→), 오른쪽 대각선 아래(↘) 순서로 탐색합니다.

- 각 이동이 가능한지 확인 후, 길이 막혀 있지 않거나 처음 가는 길이라면 그 길로 이동합니다.

3. C-1 열까지 도달할 수 있으면, 해당 행을 통해 파이프라인을 연결한 것으로 간주하고 결과를 증가시킵니다.
4. 중간에 갈 수 있는 경로가 없다면 False를 반환하여, 더 이상 탐색하지 않고 종료됩니다.

이 과정이 C-1열(빵짐)까지 도달할 수 있는 모든 경로에 대해 반복되며, 그 결과를 누적하여 최종 답을 반환한다.

## 코드 접근

**길 정보 입력**

```python
road = [list(input().strip()) for _ in range(R)]
```

입력을 공백 없이 하나의 문자열로 주어지기 때문에, 각 문자를 개별 요소로 리스트에 저장하기 위해 list()를 사용한다.

**❓왜 .split()을 사용하지 못할까?**

.split()은 기본적으로 공백을 기준으로 문자열을 나누어 리스트로 반환한다. 하지만 이 문제에서는 입력이 연속된 문자열 형태 (.xx..) 로 주어지므로, .split()을 사용하면 문자열 전체가 하나의 리스트 요소로 들어가버려 2차원 리스트 접근이 불가능하다.

**dfs**

```python
def dfs(x, y):
    if y == C - 1:
        return True

    for dx in (-1, 0, 1):
        nx = dx + x
        ny = y + 1

        if 0 <= nx < R and 0 <= ny < C:
            if road[nx][ny] != "x" and visited[nx][ny] == -1:
                visited[nx][ny] = 1
                if dfs(nx, ny):
                    return True
    return False
```

**❓ 왜 해당 코드 에서는 백트래킹 하는 부분이 없을까?**
백트래킹의 목적은 여러 경우의 수를 고려해서 최적의 해를 찾는 것이기 때문에, 그 만큼 시간 복잡도가 커지게 된다. → 시간 초과가 발생할 수 있다.

하지만, 이 문제는 **탐색 순서를 잘 조절하는 것만으로 최적의 해를 찾을 수 있으므로 백트래킹이 필요 없다.**

# ✏️ **풀이 코드**

```python
import sys
input = sys.stdin.readline
ans = 0

def dfs(x, y):
    if y == C - 1:
        return True

    for dx in (-1, 0, 1):
        nx = dx + x
        ny = y + 1

        if 0 <= nx < R and 0 <= ny < C:
            if road[nx][ny] != "x" and visited[nx][ny] == -1:
                visited[nx][ny] = 1
                if dfs(nx, ny):
                    return True
    return False

R, C = map(int, input().split()) # 길의 가로 세로 크기 입력
road = [list(input().strip()) for _ in range(R)] # 길의 빈칸과 건물 입력
visited = [[-1 for _ in range(C)] for _ in range(R)]

for i in range(R):
    if dfs(i, 0):
        ans += 1
print(ans)
```
