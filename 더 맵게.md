### **문제 설명**

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

`섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)`

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.

Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

### 제한 사항

- scoville의 길이는 2 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

### 입출력 예

| scoville | K | return |
| --- | --- | --- |
| [1, 2, 3, 9, 10, 12] | 7 | 2 |

### 입출력 예 설명

1. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
    
    새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5
    
    가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]
    
2. 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
    
    새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13
    
    가진 음식의 스코빌 지수 = [13, 9, 10, 12]
    

모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.

## 풀이

해당 문제에서는 여러음식들의 스코빌 지수와 최소제한 스코빌 지수가 주어진다.  

음식을 조합하여 모든 음식이 최소제한을 넘도록 만들어야한다.

음식을 조합할때는 최소 스코빌지수인 음식과 두번째로 낮은 스코빌 지수를 섞어서 새로운 음식을 만들 수 있다. 섞을 때 공식은 이러하다.
`섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)`

최종 음식들이 최소제한을 모두 넘도록 해야할때 최소로 섞는 횟수를 구하는 문제이다.

해당문제는 음식을 조합할때 최소와 밑에서 두번째를 섞어야하는 규칙이 있다. 따라서  최소힙을 사용하여 음식들을 저장해야한다.

최소힙에 저장 된 음식들에서 두개를 꺼내어 섞고 새로운 음식을 다시 힙에 넣어준다. 그런 뒤 최소힙에서 제일 작은 값을꺼내어 최소제한을 넘겼는지 확인 한다. 이 과정을 반복하여 최소제한을 넘기면 답을 출력하면 된다.     

---

```java
import java.util.PriorityQueue;

class Solution {
    public int solution(int[] scoville, int K) {
				//priorityqueue의 디폴트는 최소힙이다.
        PriorityQueue<Integer> heap = new PriorityQueue<>();

				//각 음식의 스코빌지수를 힙에 넣어준다.
        for(int s : scoville){
            heap.offer(s);
        }

        int ans=0;
        //힙안에 음식이 1개가 되면 더이상 섞을 수 없기때문에 2개까지만 진행해준다.
        while(heap.size()>1){
            if(heap.peek()>=K){
                break;
            }

            int newFood = heap.poll()+(heap.poll()*2);
            heap.offer(newFood);
            ans++;
        }
        //음식을 계속 섞었지만 결국 최소 제한을 넘지 못한 경우는 -1을 반환한다.
        if(heap.peek()<K){
            return -1;
        }

        return ans;
    }
    
}
```
