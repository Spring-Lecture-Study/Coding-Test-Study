# 7578. 공장 [P5]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/7578

# 💻 문제 설명

- 
    
    어떤 공장에는 2N개의 기계가 2열에 걸쳐 N개씩 배치되어 있다. 이 2개의 열을 각각 A열과 B 열이라고 부른다. 
    
    공장 작업의 효율성을 위해 기계들은 짝을 맺은 순서대로 배치되지 않으며, 필요에 따라 각 열의 기계들의 순서를 바꾼 바람에 케이블은 마구 엉켜있는 상태이다. 
    
    정수 N과 A열에 위치한 기계, B열에 위치한 기계의 식별번호가 각각 순서대로 주어질 때에 서로 교차하는 케이블 쌍의 개수를 정확하게 세어 출력하는 프로그램을 작성하시오.
    
    ![Image](https://github.com/user-attachments/assets/ffd94ca6-e293-4e56-b721-ab213b71ffae)
    
    예를 들어, 위의 그림과 같이 N = 5이고, A열에 위치한 기계의 식별번호가 순서대로 132, 392, 311, 351, 231이고 B열에 위치한 기계의 식별번호가 순서대로 392, 351, 132, 311, 231이라면 케이블들의 교차 횟수 혹은 서로 교차하는 케이블 쌍의 개수는 3이 된다.
    

# **💡 풀이 과정**

## 문제 접근

### 나의 문제 접근 - 실패

문제는 교차하는 **케이블들의 쌍의 개수**를 구하는 것이다.

**한쪽 케이블이 다른 케이블을 지나쳐 연결될 때** 교차라고 생각했다.

그래서 교차를 구하는 방법은 A배열을 순회하면서, **현재 원소의 B 인덱스가 이후 원소의 B 인덱스보다 크다면 (즉, 뒤쪽 원소가 더 앞에 있다면), 교차한 것으로 판단하고 개수를 증가**시켰다. 

**바깥 for문**에서 현재 A 배열의 원소가 B에서 위치하는 인덱스를 찾고,

**안쪽 for문**을 이용해 현재보다 뒤에 있는 원소들의 B 배열 인덱스와 비교하며 교차 케이블을 찾도록 하였다.
그러나, **이중 for문을 사용한 방식은 O(N²) 이상의 시간 복잡도를 가지므로 N이 크면 시간 초과가 발생한다.**

- **구현 코드**
    
    ```python
    import sys
    input = sys.stdin.readline
    
    N = int(input())
    a_machine = list(map(int, input().split()))
    b_machine = list(map(int, input().split()))
    
    lst = []
    ans = 0
    
    for i in range(N):
        check = b_machine.index(a_machine[i])  # O(N)
        for j in range(i + 1, N):
            if check > i:
                if check > b_machine.index(a_machine[j]):  # O(N)
                    ans += 1
    print(ans)
    ```
    

### 옳바른 문제 접근

❓ **병합 정렬?**

**분할 정복(Divide and Conquer)** 알고리즘을 사용하여 배열을 정렬하는 정렬 알고리즘.

배열을 반으로 계속 쪼갠 후, **병합(Merge) 과정**을 통해 정렬된 상태로 합친다.

이전에 접근 방법인 **O(N²이상) 브루트 포스 방식이 아니라 O(N log N)** 으로 해결할 수 있기 때문에 큰 입력에서도 빠르게 동작할 수 있다.

❓**교차의 쌍을 어떻게 구하나?**
병합 정렬에서 교차의 쌍을 구하는 방식은 **병합(Merge) 과정에서 발생하는 역순**을 **카운트**하는 방식입니다. 구체적으로, 병합 정렬에서 각 단계마다 분할된 두 부분을 병합하면서, **오른쪽 부분의 원소가 왼쪽 부분의 원소보다 작을 때**, 왼쪽 부분에서 아직 처리되지 않은 원소들의 개수만큼 교차가 발생하는 원리이다.

예제1번 값을 예시로 두면 다음과 같다.

```
5
132 392 311 351 231
392 351 132 311 231
```

**step 1: 분할**

- [2, 0] / [3, 1, 4]
- [2] / [0], [3] / [1, 4]
- [1] / [4]

**Step 2: 병합하면서 역순 개수 세기**

- [2]와 [0]을 병합하면서 역순 1개 발생 (0이 2보다 작음)
- [1]과 [4]를 병합하면서 역순 없음
- [3]과 [1, 4]를 병합하면서 역순 1개 발생 (3이 1보다 크고, 1과 4가 처리될 때까지 기다리므로 1번 발생)
- [0, 2]와 [1, 3, 4]를 병합하면서 역순 1개 발생 (2가 1보다 크므로 교차 1개 발생)

결과적으로, **총 3개의 교차 쌍**이 발생하게 됩니다.

## 코드 접근

```python
position = {value: index for index, value in enumerate(B)}
A_mapped = [position[value] for value in A]
```

enumerate를 사용하면 반복 가능한(iterable) 객체의 각 요소와 인데스를 튜플형태로 반환할 수 있다. 그리고 이를 딕셔너리 컴프리헨션을 이용해 각 원소를 **키**로, 해당 인덱스를 **값**으로 하는 딕셔너리를 만들 수 있다.

이를 통해 리스트 A의 값들을 B에서의 위치로 변환할 수 있어, 이후 정렬 시 B에서의 상대적 순서를 기준으로 정렬할 수 있습니다.

```python
result.extend(left[i:])    
result.extend(right[j:])
```

extend() 함수는 리스트에 다른 리스트를 붙여넣는 역할을 합니다.

left와 right를 비교하면서 result에 하나씩 넣다 보면, 어느 한쪽이 먼저 끝나는 경우가 생긴다.
그럼 나머지 값들은 정렬이 이미 되어 있으니까 그냥 한 번에 extend()로 붙여주면 된다.

# ✏️ **풀이 코드**

```python
import sys

input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

position = {value: index for index, value in enumerate(B)}
A_mapped = [position[value] for value in A]

def merge_sort(arr):
    if len(arr) < 2:    # 주어진 배열이 2보다 작다면, 교차하는 쌍이 없으므로 배열과 0을 반환
        return arr, 0

    mid = len(arr) // 2
    left, left_inv = merge_sort(arr[:mid])
    right, right_inv = merge_sort(arr[mid:])

    merged, split_inv = merge(left, right)  # 병합된 배열과 역순 쌍 반환

    return merged, left_inv + right_inv + split_inv

def merge(left, right):
    result = []
    i = j = inv_count = 0

    while i < len(left) and j < len(right):    # left, right 배열 안에 있는 요소까지만 비교
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            inv_count += len(left) - i
            j += 1

    result.extend(left[i:])    # 남는 부분 추가
    result.extend(right[j:])

    return result, inv_count

_, answer = merge_sort(A_mapped)
print(answer)
```
