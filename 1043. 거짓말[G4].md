# 1043. 거짓말[G4]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1043

# 💻 문제 설명
    
지민이는 파티에 갈 때마다, 지민이가 가장 좋아하는 이야기를 한다. 이때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 

하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또 다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 **이런 일을 모두 피해야 한다.**

사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

## 문제 접근

N과 M의 크기가 크지 않으므로, **브루트 포스(완전 탐색)** 으로 접근했다.

문제의 핵심은 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있어야 하는 파티 개수를 구하는 것이다. 즉, **파티에 진실을 아는 사람이 없어야 한다.**

그래서 파티를 참석한 사람의 번호가 진실을 아는 사람의 번호가 적혀 있는 배열에 있는지 확인하고 없을 때 결과 개수를 증가시키도록 접근하였다.

하지만 예제를 봤을 때 이해가 안되는 부분이 있었다.

**예제 4번**

```
4 5
1 1   # 진실을 아는 사람의 수와 번호
1 1   # X
1 2   # O
1 3   # O
1 4   # O
2 4 1 # X
```

이렇게 입력이 주어졌을 때 진실을 아는 사람의 번호는 1번 밖에 없으므로, 거짓말할 수 있는 파티의 개수는 3이라고 생각했다.

하지만 정답은 2였고 이때, 내가 놓치고 있는 부분이 있다고 생각했다.

그런데 여러 번 봐도 왜 2가 나왔는지 이해하지 못했고, 구글링을 통해 이 부분에 대해서만 찾아서 알게 되었습니다.

핵심은 다음과 같습니다.

<aside>
💡

파티에 진실을 아는 사람이 **한 명이라도 있다면**, 지민이는 거짓말쟁이가 됩니다. 그러면 파티에서 진실을 모르는 사람들도 지민이가 거짓말 쟁이라는 것을 알게 되므로, 다른 파티에 해당 인원이 참여하게 되면, 그 파티에 인원들도 지민이가 거짓말을 친 것을 알게 된다.

</aside>

 

이런한 점을 예제4에 적용하게 되면 다음과 같습니다.

```
4 5
1 1   # 진실을 아는 사람의 수와 번호
1 1   # X
1 2   # O
1 3   # X
1 4   # X 
2 4 1 # X # 1번으로 인해 4번은 이야기가 거짓임을 알게 됨.
```

하지만, 이러한 사실을 알고도 문제에 구현하지 못했고, 다른 사람에 코드를 참조하게되었습니다.

# ✏️ **풀이 코드**

## 나의 코드와 개선해야할 점

### **🧑‍💻 나의 코드**

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
truth = list(map(int, input().split()))  
ans = 0

part = []

for _ in range(M):
    num = list(map(int, input().split()))
    part.append(num[1:])

while True:
    # 확인하는 과정
    for participation in part:
        check = True
        for i in range(len(participation)):
            if participation[i] in truth[1:]:
                check = False
            elif not check and participation[i] not in truth[1:]:
                truth.append(participation[i])
        if check:
            ans += 1
    break
print(ans)
```

1️⃣ **진실을 알게 되는 사람이 추가될 경우 다시 확인하는 로직이 없음**

한 번의 반복만 수행하고 break로 종료되기 때문에, 새롭게 진실을 알게 되는 사람을 추가 못함

- **해결 방법**: 새로운 사람이 진실을 알게 되면 다시 전체 파티를 확인하도록 해야 함. (반복적인 체크 필요)

**2️⃣ truth.append()를 사용하여 중복된 인원이 들어갈 가능성이 있음**

truth 리스트에 사람을 추가할 때 **중복을 검사하지 않기 때문에** 같은 사람이 여러 번 추가될 수 있다.

- **해결 방법**: list 대신 **set**을 사용하면 중복을 자동으로 제거할 수 있음.

**3️⃣ truth[1:]을 사용할 경우 일부 진실을 아는 사람이 누락될 수 있음**

기존의 truth 리스트를 직접 수정하는 것이 아니라 truth[1:]을 매번 새로 만들기 때문에, 처음 truth에 있던 진실을 아는 사람의 수이무시될 위험이 있다.

- **해결 방법**: truth = set(truth[1:])로 처음부터 set을 써서 관리하면 첫 번째 값을 버리는 실수를 방지할 수 있음.

**4️⃣ check 변수 논리가 잘못됨**

check 변수가 한 번 False가 되면 이후 모든 사람을 무조건 추가한다는 것입니다.

즉, 진실을 아는 사람이 등장하면 check = False로 설정되는데, 그 후 남은 사람들도 무조건 truth 리스트에 추가되므로, 원래는 진실을 몰랐던 사람도 잘못 추가될 수 있다.

- **해결 방법: 집합(set)**을 사용하여 truth와 participation의 **교집합**이 있을 때만 추가하도록 수정해야 합니다.

### **🧑‍💻 다른 사람 코드 - 집합(set) 사용**

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
knowList = set(input().split()[1:])
parties = []

for _ in range(m):
    parties.append(set(input().split()[1:]))

for _ in range(m):
    for party in parties:
        if party & knowList: # "&" 교집합을 통해 겹치는 번호가 있는지 확인 
            knowList = knowList.union(party)  # ".union"을 통해 병합

cnt = 0
for party in parties:
    if party & knowList:
        continue
    cnt += 1

print(cnt)
```

출처: https://ku-hug.tistory.com/148

## 코드 접근

### 각 파티의 참여 인원 초기화

```python
for _ in range(m):
    parties.append(set(input().split()[1:]))
```

입력값의 첫 번째 요소(파티 인원 수)는 필요하지 않으므로, 리스트 슬라이싱 [1:]을 사용하여 제외합니다.

**집합** 형태로 저장하여 리스트에 저장한다.

이때 값들을 세트 자료형에 저장하는 이유는, 나중에 진실을 아는 사람과 비교할 때(교집합 & 연산) 빠르게 확인할 수 있기 때문이다.

- set을 사용하면 평균적으로 **O(1)** 연산이 가능하지만, list를 사용하면 **O(n)** 연산이 필요하다.

입력 1번을 예시로 들면,

```python
4 3
0
2 1 2
1 3
3 2 3 4

parties = [
    {"1", "2"},
    {"3"},
    {"2", "3", "4"}
]
```

### 진실을 알고 있는 인원 초기화

```python
for _ in range(m):
    for party in parties:
        if party & knowList: # "&" 교집합을 통해 겹치는 번호가 있는지 확인 
            knowList = knowList.union(party)  # ".union"을 통해 병합
```

set 자료형에서 제공하는 **"&"** (교집합) 연산자와 **".union()**" (합집합) 메서드를 사용하여,
각 파티별 참여하는 인원에 접근한 후, 진실을 알고 있는 인원이 있다면 해당 파티의 모든 사람을 추가한다.

이를 m번 반복하는 이유는, 처음에는 몰랐던 사람이 순차적으로 진실을 알게 될 수도 있기 때문이다. (예제 4번)

- 교집합이나 합집합을 사용할 때, **“&”,** **“|”** 처럼 연산자나 **“.intersection()”**, **“.union”** 처럼 함수 로도 구현이 가능하다.

### 🧑‍💻**gpt가 알려준 코드 - BFS**

```python
import sys
from collections import deque

input = sys.stdin.readline

n, m = map(int, input().split())  # 사람 수 n, 파티 수 m
truth_set = set(map(int, input().split()[1:]))  # 진실을 아는 사람 집합
parties = []  # 파티 리스트
graph = [set() for _ in range(n + 1)]  # 사람 간 연결 그래프 (1~N)

for _ in range(m):
    party = set(map(int, input().split()[1:]))  # 🔹 정수 변환
    parties.append(party)

    # 그래프 연결 (같은 파티 내 사람들을 연결)
    for person in party:
        for other in party:
            if person != other:
                graph[person].add(other)

# BFS를 활용하여 진실을 퍼뜨림
queue = deque(truth_set)

while queue:
    person = queue.popleft()
    for neighbor in graph[person]:
        if neighbor not in truth_set:
            truth_set.add(neighbor)
            queue.append(neighbor)

# 거짓말 가능 파티 개수 계산
answer = sum(1 for party in parties if not any(person in truth_set for person in party))

print(answer)

```

## 코드 접근

### 그래프 생성

```python
graph = [set() for _ in range(n + 1)]  # 사람 간 연결 그래프 (1~N)
```

이렇게 그래프를 구성하는 이유는 같은 파티에 참석한 사람들은 서로 연결되어 있기 때문에,
한 사람이 진실을 알게 되면 같은 파티에 있던 다른 사람들에게도 **진실이 전파**될 수 있도록 그래프 구조를 활용하는 것이다.

사람 번호를 1번부터 사용하기 때문에, 리스트 크기를 n+1로 설정해서 인덱스 1~n까지 설정한다.

ex/ n이 5라면?

```python
graph = [
    set(),  # 0번 인덱스 (사용 안 함)
    set(),  # 1번 사람과 연결된 사람들
    set(),  # 2번 사람과 연결된 사람들
    set(),  # 3번 사람과 연결된 사람들
    set(),  # 4번 사람과 연결된 사람들
    set(),  # 5번 사람과 연결된 사람들
]
```

### 그래프 연결

```python
for _ in range(m):
    party = set(map(int, input().split()[1:]))  # 문자열로 만들면 인덱스로 접근할 때, 
    parties.append(party)                       # 에러가 발생한다.

    # 그래프 연결 (같은 파티 내 사람들을 연결)
    for person in party:
        for other in party:
            if person != other:
                graph[person].add(other)
```

**✔ 파티 참석자 저장**
각 파티에 참여하는 인원들을 정수형으로 변환한 후 집합(set)으로 저장하고 parties 리스트에 추가한다.
**✔ 그래프 연결**
같은 파티에 참석한 사람들은 서로 연결되어 있다고 가정하고, 각 사람을 다른 참석자와 연결하는 방식으로 그래프를 구성한다.

- 만약 현재 **파티에 참석한 인원이 한 명이라면**, 연결할 사람이 없으므로 **그대로 넘어간다**.

이렇게 그래프를 구성하면, 같은 파티에 참석했던 사람들은 간접적으로라도 연결된 관계가 된다. 이후 BFS(너비 우선 탐색)를 활용하여 진실을 아는 사람과 연결된 모든 사람을 찾아낼 수 있다.

### 진실 전파

```python
# BFS를 활용하여 진실을 퍼뜨림
queue = deque(truth_set)

while queue:
    person = queue.popleft()
    for neighbor in graph[person]:
        if neighbor not in truth_set:
            truth_set.add(neighbor)
            queue.append(neighbor)
```

**BFS(너비 우선 탐색)**와 **queue(큐)**를 사용하여, 진실을 알고 있는 사람과 연결된 모든 사람에게 진실을 전파한다.

**✔ 초기화**

처음에 truth_set(진실을 알고 있는 사람들)을 queue에 삽입한다.
BFS 탐색을 수행하면서 **큐에서 한 사람씩 꺼내고**, 그 사람이 연결된 다른 사람을 확인한다.

**✔ 진실 전파 과정**

1. queue에서 한 사람(person)을 꺼낸다.
2. 해당 사람이 graph에서 연결된 사람들(neighbor)을 확인한다.
3. 만약 연결된 사람이 아직 truth_set에 포함되지 않았다면:
- 진실을 알게 되었으므로 truth_set에 추가한다.
- 이후, 큐에 삽입하여 다시 탐색할 수 있도록 한다.
이 과정을 큐가 빌 때까지 반복, 진실을 아는 사람과 연결된 모든 사람이 진실을 알게 된다.

**❓큐에 다시 삽입하는 이유?**

순서에 따라 나중에 진실을 알게 되는 경우가 있을 수 있기 때문에, 큐에 넣어 FIFO(First-In First-Out, 선입선출) 방식으로 순차적으로 탐색할 수 있도록 한다.
즉, 먼저 진실을 알게 된 사람부터 차례로 탐색하며 연결된 사람들에게 진실을 전파한다.

### 거짓말 할 수 있는 파티 계산

```python
answer = sum(1 for party in parties if not any(person in truth_set for person in party))
```

위 코드는 **제너레이터 표현식(generator expression)**을 사용하여 거짓말을 할 수 있는 파티의 개수를 효율적으로 계산하는 방식이다.

나눠서 설명하면,

**for party in parties:**
→ parties 리스트에서 각 party(파티에 참석한 사람들의 집합)를 순회한다.

**any(person in truth_set for person in party):**
→ 해당 party에 속한 사람 중에서 진실을 아는 사람이 하나라도 있으면 True, 없으면 False.

**if not any(...):**
→ any()가 False이면, 즉 해당 파티에 진실을 아는 사람이 한 명도 없으면, sum(1)을 수행하여 카운트를 증가시킨다.

**sum(1 for party in parties if not any(...)):**
→ True가 되는 경우마다 1을 더하여 최종적으로 거짓말을 할 수 있는 파티 개수를 계산한다.
