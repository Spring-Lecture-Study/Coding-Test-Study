# 1931. 회의실 배정[S1]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1931

# 💻 문제 설명

- 
    
    한 개의 회의실이 있는데, 이를 사용하고자 하는 N개의 회의에 대해서 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어졌을 때, 각 회의가 격치지 않게 하면서 회의실을 사용할 수 있는 회의에 최대 개수를 구하라.
    
    **주의 사항**
    단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
    

# **💡 풀이 과정**

## 문제 접근

I를 2차원 배열로 저장받는다. 그런 다음 오름차순으로 정렬한 뒤, 반복문을 통해 회의 시작시간이 끝나는 시간과 같거나 이후일 때 결과값을 1씩 증가시키고, 그게 아니라면 다음 반복문으로 넘어간다. 이런식으로 모든 반복문을 순회가 끝나면 결과를 출력한다.

- 내가 이렇게 접근 한 이유는, 처음 회의 끝나는 시간 후에 가장 가까운 회의 시작 시간을 잡아야 효율적이라고 생각했기 때문이다.

# ✏️ **풀이 코드**

```python
N = int(input())
I = [list(map(int, input().split())) for _ in range(N)]

ans = 1
end_time = I[0][1]

I.sort()

for i in range(1, N):
    start_time = I[i][0]
    if start_time >= end_time: # 현재 회의 시작시간이 전 회의 시간 후 시간과 같거나 클 떄
        ans += 1
        start_time = I[i][0]
        end_time = I[i][1]
    else:
        continue
print(ans)
```

이 코드가 틀린 이유는 정렬 기준이 잘못되었기 때문이다. I.sort()를 사용하면 기본적으로 회의의 시작 시간(start_time)을 기준으로 정렬된다. 하지만, 회의실 배정 문제의 최적해를 구하기 위해서는 "끝나는 시간(end_time)"을 기준으로 정렬해야 한다. 왜냐하면 끝나는 시간이 빠를수록 이후의 회의를 선택할 기회가 많아지기 때문이다.

# ✏️ **풀이 코드**

```python
N = int(input())
I = [list(map(int, input().split())) for _ in range(N)]

# 끝나는 시간 기준으로 정렬 (끝나는 시간이 같으면 시작 시간으로 정렬)
I.sort(key=lambda x: (x[1], x[0]))

ans = 0
end_time = 0

for start_time, finish_time in I:
    if start_time >= end_time:  # 현재 회의 시작 시간이 이전 회의 종료 시간 이후라면
        ans += 1
        end_time = finish_time  # 종료 시간을 갱신

print(ans)
```

## 📋 주요 코드 설명

```python
I.sort(key=lambda x: (x[1], x[0]))
```

이 구문은 정렬 기준을 지정하여 리스트를 정렬하는 코드입니다. lambda를 사용하여 사용자 정의 정렬 기준을 설정한다.

기본적으로 sort() 함수는 첫 번째 요소를 기준으로 오름차순 정렬한다. 하지만, key 매개변수를 사용하여 정렬 기준을 커스터마이징할 수 있다.

- key는 정렬 기준을 정의한다.
- lambda x: (x[1], x[0])는 리스트의 각 원소 x를 처리하는 익명 함수이다.
- sort 메서드에서 key에 제공된 함수의 반환값은 기본적으로 "첫 번째 값"을 기준으로 오름차순 정렬 한다. 그리고, 첫 번째 값이 동일한 경우, 두 번째 값을 기준으로 정렬하는 방식으로 동작한다.

**내림차순 정렬**

```python
I.sort(key=lambda x: (-x[1], -x[0]))
```

- 만약 내림차순으로 정렬하고 싶다면, 위와 같이 매개변수에 “-”을 붙이면 된다.

**언패킹**

```python
for start_time, finish_time in I:
```

이 구문은 언패킹(unpacking) 기능을 활용한 문법이다.

이렇게 하면 2차원 리스트에 첫 번째 요소는 start_time에 두 번째 요소는 finish_time에 들어가게 된다.

# ✏️ **풀이 코드(Java)**

```python
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 입력받기
        int N = sc.nextInt();
        int[][] meetings = new int[N][2];
        for (int i = 0; i < N; i++) {
            meetings[i][0] = sc.nextInt(); // 시작 시간
            meetings[i][1] = sc.nextInt(); // 종료 시간
        }

        // 정렬: 종료 시간 기준 -> 시작 시간 기준
        Arrays.sort(meetings, (a, b) -> {
            if (a[1] == b[1]) {
                return Integer.compare(a[0], b[0]); // 종료 시간이 같으면 시작 시간 기준
            }
            return Integer.compare(a[1], b[1]); // 종료 시간 기준
        });

        // 회의실 배정 로직
        int ans = 0;
        int endTime = 0;
        for (int i = 0; i < N; i++) {
            if (meetings[i][0] >= endTime) { // 시작 시간이 종료 시간보다 크거나 같은 경우
                ans++;
                endTime = meetings[i][1];
            }
        }

        // 결과 출력
        System.out.println(ans);
    }
}
```

## 📋 주요 코드 설명

```python
Arrays.sort(meetings, (a, b) -> {
      if (a[1] == b[1]) {
          return Integer.compare(a[0], b[0]); // 종료 시간이 같으면 시작 시간 기준
      }
      return Integer.compare(a[1], b[1]); // 종료 시간 기준
  });
```

Arrays.sort() 메서드는 기본적으로 배열의 값을 **오름차순** 정렬을 수행합니다. 또한, 두 번째 인자로 람다식을 사용하여 정렬 기준을 커스터마이즈할 수 있습니다.
이 코드에서 사용된 람다식은 두 가지 기준으로 정렬합니다:

1. **종료 시간 (a[1], b[1])**을 기준으로 오름차순 정렬.
2. 종료 시간이 같다면 **시작 시간 (a[0], b[0])**을 기준으로 오름차순 정렬.
- 만약, 내림차순으로 정렬하려면 Integer.compare(b, a)로 변경하면 됩니다.

# 📒 **풀이 후기**

언패킹 하는 방법이랑, 람다식에 대해 알 수 있어서 좋은 문제였다.
