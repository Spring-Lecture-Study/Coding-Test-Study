# 11047. 동전 0[S4]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/11047

# 💻 문제 설명

- 
    
    준규가 가지고 있는 동전은 총 N종류이고, 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최소값을 구하는 프로그램을 작성하라.
    

# **💡 풀이 과정**

## 문제 접근

최소한의 동전 개수로 K값을 만들기 위해서는 가장 큰 가치의 동전을 우선적으로 사용하는 것이 효율적이다. 따라서, 동전의 가치를 내림차순으로 정렬한 후 K값을 반복적으로 나누고 계산하는 방식으로 접근한다.

N크기 만큼 반복문을 순회하면서 동전의 종류를 입력받아 리스트에 저장한 후, 내림차순으로 정렬한다. 정렬된 동전을 순회하면서, 현재 동전의 가치가 K보다 작거나 같다면, 해당 동전으로 K를 나눕니다. **몫**은 결과 변수에 더하고, **나머지**는 K로 갱신한다. 이렇게 연산을 진행하면서 K가 0이 되면 누적된 결과를 출력한다.

- 원래는 내림차순으로 정렬 후, 비교할려고 했으나 정렬 작업은 추가적인 시간 복잡도를 소모하므로, 리스트 인덱싱을 통해 -i~ N +1 순으로 가장 뒤에 있는 값부터 순회하도록 한다.

만약, 해당 값이 K보다 크다면 나눌수 없기 때문에 , continue를 통해 다음 반복문을 넘어간다.

# ✏️ **풀이 코드**

```java
N, K = map(int, input().split())

lst = []
ans = 0 #K원을 만드는데 필요한 총 동전의 개수
for _ in range(N): # N 크기 만큼 동전 종료 받기
    lst.append(int(input()))

for i in range(1, N+1):
    if lst[-i] > K:
        continue
    ans += K // lst[-i]
    K = K % lst[-i]
    if K == 0:
        break
print(ans)
```

## 📋 주요 코드 설명

```java
for i in range(1, N+1):
    if lst[-i] > K:
        continue
    ans += K // lst[-i]
    K = K % lst[-i]
    if K == 0:
        break
```

- lst[i]가 K보다 크다면, 다음 반복문으로 넘어가게 하고, 작다면 나눗셈의 몫을 K에 누적시키고 나머지를 K에 갱신시켜 나머지 연산을 이어가도록 한다. 나누었을 때 K 값이 0이 된다면, 결과를 출력한다.

# ✏️ **풀이 코드(Java)**

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int K = sc.nextInt();
        Integer [] lst = new Integer[N];
        int ans = 0;

        // 배열에 동전 종류 넣기
        for (int i = 0; i < N; i++) {
            lst[i] = sc.nextInt();
        }
        // 배열 내림차순으로 정렬
        Arrays.sort(lst, Collections.reverseOrder());

        for (int i = 0; i< N; i++) {
            if (lst[i] > K) {
                continue;
            }
            ans += K / lst[i];
            K = K % lst[i];
            if (K == 0) {
                break;
            }
        }
        System.out.println(ans);
    }
}
```

## 📋 주요 코드 설명

```java
Integer [] lst = new Integer[N];

Arrays.sort(lst, Collections.reverseOrder());
```

- 자바에서는 Python처럼 -1, -2, -3 등의 음수 인덱스를 사용하여 리스트나 배열의 뒤쪽 요소에 직접 접근할 수는 없기 때문에 정렬을 해야한다.
- 오름차순 정렬은 Arrays.sort()를 사용하면 기본 타입 배열인 **int[]**에서도 사용할 수 있다. 하지만, 내림차순 정렬을 하려면 **Comparator**가 필요하며, Collections.reverseOrder()는 **객체 배열(Integer[])**에서만 동작합니다. 따라서 배열 타입을 Integer[]로 선언해야 하고, Arrays.sort(lst, Collections.reverseOrder())를 사용하여 내림차순 정렬을 수행한다.
- Comparator는 정렬 기준을 정의하는 **인터페이스**이며, Collections.reverseOrder()는 이를 구현해 내림차순 정렬을 제공한다.

# 📒 **풀이 후기**

실버 문제 치고는 문제가 쉬워 20분만에 풀었다. 그래도 이렇게 쉬운 문제가 나온다면 더 시간을 단축할려고 노력해봐야 겠다.
