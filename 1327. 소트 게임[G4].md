# 1327. 소트 게임[G4]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1327

# 💻 문제 설명

- 
    
    소트 게임을 하려고 한다. 소트 게임은 1부터 N까지의 정수로 이루어진 순열을 이용하고, K개가 주어지면 K크기 만큼 순열을 선택해서 그 수부터 오른쪽으로 K개의 수를 뒤집어야 한다. 
    
    입력으로 들어온 순열을 오름차순으로 만들려고 한다. 게임을 최대한 빨리 끝내고 싶을 때, 수를 최소 몇 개 선택해야 하는지 구해보자.
    

# **💡 풀이 과정**

## 문제 접근

문제는 Bfs와 Queue를 활용하여 풀면 된다.

주어진 순열을 오름차순으로 정렬한 리스트를 목표값으로 설정하고, 현재 순열에서 가능한 모든 경우를 K개의 연속된 숫자를 뒤집어 탐색한다. 

Queue를 활용하여 최소한의 연산 횟수로 목표 상태에 도달하는 경우를 찾으며, 중복 탐색을 방지하기 위해 set을 사용하여 방문한 순열을 저장하고 확인한다. 

목표 상태와 동일한 순열이 나오면 뒤집은 횟수를 출력하며, 모든 경우를 탐색해도 목표 상태를 만들 수 없다면 **-1**을 출력한다.

❓ 세트를 사용하는 이유?

이 문제에서는 **리스트 자체**가 방문 체크의 기준이므로, 단순한 인덱스 기반 boolean 배열을 사용할 수 없다. 또한, set은 해시 테이블 기반이므로 평균적으로 **O(1)**의 시간 복잡도로 탐색이 가능하다. 그러나 list를 사용하여 방문 여부를 확인하려면 **O(N)**의 시간이 걸리므로, set을 사용하는 것이 훨씬 효율적이다.

## 코드 접근

```python
for i in range(n - k + 1): # 뒤집을 구간의 시작 위치 설정
    new_list = current[:i] + current[i:i + k][::-1] + current[i + k:]
    queue.append((new_list, count + 1))
```

i는 뒤집을 구간의 시작 위치를 의미한다.

- 예를 들어, n=5, k=3이라면 i는 0, 1, 2의 위치에서 뒤집기가 가능하다.

new_list에 뒤집은 리스트를 저장한다.

- 뒤집을 구간의 시작값 이전값과 뒤집을 크기의 이후 값 그대로 두고,  k크기의 뒤집을 값들은 python 리스트의 **“[::-1]”** 을 활용하여 해당 구간을 반대로 뒤집는다.
- 이 방법을 통해 해당 구간을 **오른쪽으로 뒤집는 것처럼 보이도록** 순서가 반대로 정렬된다.

# ✏️ **풀이 코드**

```python
from collections import deque

n, k = map(int, input().split())
arr = list(map(int, input().split()))

target = sorted(arr)  
queue = deque([(arr, 0)])  
visited = set()  

while queue:
    current, count = queue.popleft()

    if current == target:
        print(count)
        exit()  

    current_tuple = tuple(current)
    if current_tuple in visited:
        continue
    visited.add(current_tuple)

    for i in range(n - k + 1):
        new_list = current[:i] + current[i:i + k][::-1] + current[i + k:]
        queue.append((new_list, count + 1))

print(-1)
```
