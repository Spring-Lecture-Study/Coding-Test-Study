# 2580. 스도쿠

### 🌐 문제 링크:

https://www.acmicpc.net/problem/2580

# 💻 문제 설명

- 
    
    아홉 줄에 걸쳐 한 줄에 9개씩, 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 
    
    스도쿠 판의 빈 칸의 경우에는 0이 주어진다.
    이때 0을 스도쿠 규칙에 따라 채워 넣어 완성된 스도쿠판을 출력한다.
    

# **💡 풀이 과정**

## 문제 접근

스도쿠판을 저장하는 배열과 한 행에 열 값이 저장되어 있는 1차원 배열을 만든다.
for문을 통해 열을 탐색하면서 해당 열에 0이 있다면 for문을 통해 1부터 9까지 값을 증가시키면서 해당 행과 비교하여 없는 값만 집어넣을 수 있도록 한다. 그렇게 재귀 호출을 통해 다음 행의 열을 탐색할 수 있도록 하고, 비교하는 행 값이 9가 된다면 스도쿠인지 확인하는 방법을 통해 맞다면 출력하고 아니라면 return을 통해 백트래킹 방법으로 돌아가서 모든 경우의수를 구할 수 있도록 한다.

위 방법은 내가 처음에 생각한 문제 접근 방법이다. 이 방법은 모두 틀렸다고 할 수는 없지만 개선한다고 하면 다음과 같이 수정할 수 있다.

### 2차원 배열 활용

 1차원 배열을 활용하여 빈 칸의 위치를 1차원 배열로 저장해놓고, 그 위치에 있는 값을 기준으로 순차적으로 탐색하는 방법도 있다. 하지만 스도쿠를 해결하는데에는 2차원 배열이 자연스럽고 직관접이다.

### 중복 값 체크 방법

위 접근 방법에는 기술하지 않았지만, 해당 열과 행을 탐색하면서 숫자가 중복만 안되면 스도쿠 게임 규칙에 해당한다고 생각했고, 모든 행을 탐색해서 값을 넣게 됐을 때 한번에 규칙에 맞는 스도쿠판이 완성될 수 있지만 , 안될 수 있다 판다하여 이떄, 백트래킹 하여 값을 탐색한다고 생각했었다. 하지만 빈 값에 값을 넣을 때 같은 행, 열, 3x3 박스 를 체크하고 중복되지 않는 값들을 넣으면 완성된 스도쿠판을 만들 수 있기 때문에 모든 행을 탐색하게 되면 이때, 해당 스도쿠판을 출력하면 된다. 또한 백트래킹 하는 시점은 해당 열에 해당하는 값이 없다면 이때 백트랙킹을 통해 돌아가서 이전 값 이후에 값을 탐색하도록 하여 다른 값을 넣도록 하면 된다. 

그래서 이러한 접근들을 코드에 적용하면, 

1. **행, 열, 3x3 박스를 체크하는 메서드**를 생성하여, 각 빈 칸에 숫자를 넣기 전에 해당 숫자가 유효한지 확인한다.
2. **dfs 메서드**에서는 주어진 행을 탐색하고, 각 열에 대해 빈 칸이 있을 경우 유효한 숫자를 넣습니다. 만약 해당 숫자가 유효하다면, 그 값을 넣고 **다음 행으로 넘어가기 위해 행 값을 증가**시키고 재귀적으로 호출한다.
3. **모든 행을 탐색**하여 스도쿠가 완성되면, 각 행의 값을 **StringBuilder에 저장**하고, 모든 값을 공백을 기준으로 출력합니다. 스도쿠 판이 완성되면 **메서드를 종료한다.**

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {

    public static final int SIZE = 9;
    public static final int BOX_SIZE = 3;
    public static int[][] arr = new int[SIZE][SIZE];

    public static boolean possibility(int row, int col, int value) {

        // 행 열 체크
        for (int i = 0; i < SIZE; i++) {
            if (arr[row][i] == value || arr[i][col] == value) {
                return false;
            }
        }

        // 3*3 칸에 중복되는 원소가 있는지 검사
        int set_row = (row / BOX_SIZE) * BOX_SIZE; // value가 속한 3x3의 행의 첫 위치
        int set_col = (col / BOX_SIZE) * BOX_SIZE; // value가 속한 3x3의 열의 첫 위치

        for (int i = set_row; i < set_row + BOX_SIZE; i++) {
            for (int j = set_col; j < set_col + BOX_SIZE; j++) {
                if (arr[i][j] == value) {
                    return false;
                }
            }
        }

        return true; // 중복되는 것이 없을 경우 true 반환
    }

    public static void sudoku(int row, int col) {

        // 해당 행이 다 채워졌을 경우 다음 행의 첫 번째 열부터 시작
        if (col == SIZE) {
            sudoku(row + 1, 0);
            return;
        }

        // 행과 열이 모두 채워졌을 경우 출력 후 종료
        if (row == SIZE) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < SIZE; i++) {
                for (int j = 0; j < SIZE; j++) {
                    sb.append(arr[i][j]).append(' ');
                }
                sb.append('\n');
            }
            System.out.println(sb);
            // 출력 뒤 시스템을 종료한다.
            System.exit(0);
        }

        // 만약 해당 위치의 값이 0 이라면 1부터 9까지 중 가능한 수 탐색
        if (arr[row][col] == 0) {
            for (int i = 1; i <= SIZE; i++) {
                // i 값이 중복되지 않는지 검사
                if (possibility(row, col, i)) {
                    arr[row][col] = i;
                    sudoku(row, col + 1);
                }
            }
            arr[row][col] = 0;
            return;
        }

        sudoku(row, col + 1);

    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        for (int i = 0; i < SIZE; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < SIZE; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        sudoku(0, 0);

    }
}
```

출처: https://st-lab.tistory.com/119

## 📋 주요 코드 설명

```java
// 만약 해당 위치의 값이 0 이라면 1부터 9까지 중 가능한 수 탐색
if (arr[row][col] == 0) {
    for (int i = 1; i <= SIZE; i++) {
        // i 값이 중복되지 않는지 검사
        if (possibility(row, col, i)) {
            arr[row][col] = i;
            sudoku(row, col + 1);
        }
    }
    arr[row][col] = 0;
    return;
}

sudoku(row, col + 1);
```

현재 주어진 행과 열 값이 0이라면, 1부터 9까지 가능한 값 중 possibility(row, col, i) 메서드로 중복되지 않는 값만 해당 위치에 넣습니다. 그런 다음, 열을 증가시켜 다음 위치를 탐색하기 위해 sudoku(row, col + 1)을 재귀 호출합니다. 만약 중복되지 않는 값이 없다면, 해당 위치의 값을 0으로 되돌리고 return을 사용하여 현재 함수의 실행을 종료시킵니다. 이때, return이 실행되면 이전에 호출된 위치로 돌아가며, 그곳에서 반복문은 이전 값 이후의 값부터 다시 탐색을 시작합니다.

예를 들어, arr[0][2]에 2를 넣고 다음 열(arr[0][3])을 탐색했는데 조건에 맞는 값이 없다면, arr[0][3]을 0으로 설정하고 return합니다. 이전 호출로 돌아오면 arr[0][2]를 0으로 초기화하고 반복문에서 2 이후의 값(3, 4, ..., 9)을 탐색합니다. 이렇게 하는 이유는 추가로 arr[0][2] 값을 2를 넣어서 연산하는 것을 방지하고, 모든 경우의 수를 올바르게 탐색하기 위해 필수적입니다.

```java
// 해당 행이 다 채워졌을 경우 다음 행의 첫 번째 열부터 시작
if (col == SIZE) {
    sudoku(row + 1, 0);
    return;
}
```

현재 행에 대한 모든 열을 탐색한 후, 행 값을 증가시키고 열 값을 0으로 설정하여 재귀 호출한다. 이때 return 문은 다음 행을 탐색하기 위해 재귀 호출을 하며, 현재 행을 처리한 후 더 이상 해당 행에 대해 작업을 하지 않도록 하지 위해 사용된다. 만약 return을 사용하지 않으면, 현재 행을 처리한 후에도 추가적인 연산이 계속 실행될 수 있기 때문에, 현재 함수의 실행을 종료시키고 정상적으로 다음 행으로 넘어갈 수 있도록 해야한다.

# ✏️ **풀이 코드2**

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class Main {

    public static final int SIZE = 9;
    public static final int BOX_SIZE = 3;
    public static int[][] arr = new int[SIZE][SIZE];
    public static List<int[]> blank = new ArrayList<>();

    public static boolean possibility(int row, int col, int value) {

        // 행 열 체크
        for (int i = 0; i < SIZE; i++) {
            if (arr[row][i] == value || arr[i][col] == value) {
                return false;
            }
        }

        // 3*3 칸에 중복되는 원소가 있는지 검사
        int set_row = (row / BOX_SIZE) * BOX_SIZE; // value가 속한 3x3의 행의 첫 위치
        int set_col = (col / BOX_SIZE) * BOX_SIZE; // value가 속한 3x3의 열의 첫 위치

        for (int i = set_row; i < set_row + BOX_SIZE; i++) {
            for (int j = set_col; j < set_col + BOX_SIZE; j++) {
                if (arr[i][j] == value) {
                    return false;
                }
            }
        }

        return true; 
    }

    public static void sudoku(int n) {

        // 현재 탐색 중인 빈칸의 인덱스가 빈칸 리스트의 크기와 같다면(모든 빈칸을 채웠다면), 스도쿠를 출력하고 프로그램 종료
        if (n == blank.size()) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < SIZE; i++) {
                for (int j = 0; j < SIZE; j++) {
                    sb.append(arr[i][j]).append(' ');
                }
                sb.append('\n');
            }
            System.out.println(sb);
            System.exit(0);
        }

        // 현재 빈칸의 좌표
        int[] coord = blank.get(n);
        int y = coord[0];
        int x = coord[1];

        // 만약 해당 위치의 값이 0 이라면 1부터 9까지 중 가능한 수 탐색
        for (int checkNum = 1; checkNum <= 9; checkNum++) {
            if (possibility(y, x, checkNum)) {
                arr[y][x] = checkNum;
                sudoku(n + 1);
                arr[y][x] = 0;
            }
        }
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        for (int i = 0; i < SIZE; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < SIZE; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
                if (arr[i][j] == 0) {
                    blank.add(new int[]{i, j});
                }
            }
        }

        sudoku(0);

    }
}
```

해당 풀이가 맨 위 풀이보다 40ms 시간을 단축할 수 있는 방법이다.

## 📋 주요 코드 설명

```java
for (int i = 0; i < SIZE; i++) {
    StringTokenizer st = new StringTokenizer(br.readLine(), " ");
    for (int j = 0; j < SIZE; j++) {
        arr[i][j] = Integer.parseInt(st.nextToken());
        if (arr[i][j] == 0) {
            blank.add(new int[]{i, j});
        }
    }
}
```

스도쿠판의 숫자를 입력받으면서, 해당 값이 빈칸(0)일 경우 해당 행과 열의 좌표를 빈칸 리스트에 저장한다.

ArrayList는 int[] 타입의 배열을 원소로 받기 때문에, 배열을 추가할 때마다 새로운 배열을 생성해 리스트에 넣는다.

new int[]{i, j}는 새로운 int[] 배열을 생성하면서 동시에 배열의 값을 {i, j}로 초기화하는 방식이다. new 키워드를 사용해 배열을 메모리에 할당하고, 중괄호 {} 안에 값을 넣어 배열의 원소들을 초기화하는 방식으로 사용된다.

```java
	// 현재 빈칸의 좌표
	int[] coord = blank.get(n);
	int y = coord[0];
	int x = coord[1];
	
	
	// 만약 해당 위치의 값이 0 이라면 1부터 9까지 중 가능한 수 탐색
	for (int checkNum = 1; checkNum <= 9; checkNum++) {
	    if (possibility(y, x, checkNum)) {
	        arr[y][x] = checkNum;
	        sudoku(n + 1);
	        arr[y][x] = 0;
		    }
		}
}
```

blank.get(n)을 통해 n번째 빈칸의 좌표를 가져와 행(y)과 열(x)에 저장한 후, 해당 위치에 들어갈 수 있는 값을 탐색한다. 가능한 값이 있으면 해당 값을 배치하고, 다음 빈칸을 채우기 위해 재귀적으로 sudoku(n + 1)을 호출합니다. 만약 값이 맞지 않으면, 해당 위치를 다시 0으로 되돌리고 다른 값을 시도한다.

# ✏️ **풀이 코드(Python)**

```python
import sys
input = sys.stdin.readline

def possibility(row, col, value):
    for i in range(9):
        if value == arr[row][i]:
            return False

    for i in range(9):
        if value == arr[i][col]:
            return False

    set_row = (row // 3) * 3
    set_col = (col // 3) * 3

    for i in range(set_row, set_row + 3):
        for j in range(set_col, set_col + 3):
            if arr[i][j] == value:
                return False

    return True

def sudoku(row, col):
    if col == 9:
        sudoku(row + 1, 0)
        return

    if row == 9:
        for line in arr:
            print(*line)
        sys.exit(0)

    if arr[row][col] == 0:
        for i in range(1, 10):
            if possibility(row, col, i):
                arr[row][col] = i
                sudoku(row, col + 1)
                arr[row][col] = 0
        return

    sudoku(row, col + 1)

arr = [list(map(int, input().split())) for _ in range(9)]
sudoku(0, 0)
```

Python3로 제출하면 시간 초과가 발생하고 PyPy3로 재출하면 통과가 된다.
